### 准备
#### 自我介绍
##### 前端版
面试官你好，我叫黄益妙，来自浙江工业大学软件工程专业的23届应届生。

作为一名软件工程的学生，我熟悉并掌握了多种前端技术，包括HTML、CSS、JavaScript等。我也具备一些比较流行的的前端框架和库的开发经验，例如bootstrap、jquery和Vue.js等。同时，我也理解前后端交互的机制以及协作工具如git的使用，并曾经和同学一起开发过一个大型车位管理系统的项目。在校期间我多次获得了学习奖学金和社会实践奖学金，积极参加竞赛，在电子商务大赛，服务外包大赛，网络安全大赛中都获得了省级以上的奖项。

我热爱学习和不断提升自己的技能，因此我经常关注前端技术的最新动态，在掘金、v2ex、github等社区阅读相关的博客和书籍。我也喜欢和其他开发者进行交流，分享我的经验和知识，偶尔在开源社区为一些开源项目提交pr，并且愿意在工作中协同团队中的其他成员，以实现最佳的开发效果。

如果给我机会成为杭州银行信息技术部的一员，我将竭尽全力为公司贡献我的技能和才华，并与团队协同工作，创造出优质的应用程序。谢谢！

##### 测试版
面试官你好，我叫黄益妙，来自浙江工业大学软件工程专业的23届应届生。

作为一名软件工程的学生，我在大学期间做过一些项目同时积累过一些测试相关的经验，能够独立地完成软件测试流程的一个工作。我之前主要做过的是功能测试，web自动化测试、app专项测试、接口测试、也有用过Jmeter做过一些性能方面的测试。同时，我也理解前后端交互的机制和开发流程以及协作工具如git的使用，并曾经和同学一起开发过一个大型车位管理系统的项目。在校期间我多次获得了学习奖学金和社会实践奖学金，积极参加竞赛，在电子商务大赛，服务外包大赛，网络安全大赛中都获得了省级以上的奖项。

我热爱学习和不断提升自己的技能，因此我经常在各大论坛上关注一些计算机领域的最新动态。我也喜欢和其他开发者进行交流，分享我的经验和知识。并且愿意在工作中协同团队中的其他成员，以实现最佳的开发效果。

#### 自身优势
我的优势大概就是持久，相对有计划性。
持久方面大概概括来说就是：持续性地练习、总结和改进，我相信我可以让一切变好。
然后计划性的话，我每天会根据相应的日程和学习任务安排，在晚上把下一天的时间安排好，然后每周末会制定下一周每天的大概任务，然后日任务的话就是根据周任务进行相对的拓展，我觉得这一步是非常有必要的，这些工作看似是多花了时间，实际上是在后续执行过程中为我们节省了大量的时间，就好比像把一个复杂的任务进行细化，相对来说会更有条理，也更有动力去完成这样一个任务。

技术能力、业务能力、沟通能力、架构能力，风险管理，编码技能，管理能力等技能，都是通过不断地练习、总结和改进才能不断提高的。而我的具体方法是通过看书，然后学习之后在自己的知识库对相应的知识点进行总结，后续也是在计划开始打造自己专属的个人博客这样，对外输出然后得到反馈也会让我得到更快的进步。

其实就目前来说，我可能跟那些名校毕业的，或者说是有很多段实习的同学来说，起点上还是有些差距的。意识到这个差距之后，我倒是能沉得下心来，去规划一些想做的事情，去长期的做一些事情。所以，我会以年为单位去做一些事情，以月为单位去做一些事情。

对于一个前端工程师来说，编码方面肯定是重中之重的，这不必说，我计划中的对应的练习包括：

* 阅读开源软件代码，再造个精简的轮子（最近是在计划阅读vuejs设计和实现
* 练习 TDD、重构、测试、代码规范等 （之前是看过一本名叫clean code的书，里面就是详细阐释了在业务交付时间有限的情况下好代码和烂代码产生的巨大的差异，然后里面也是对代码规范进行了对应的规定吧，平时编码我也会注意这方面）
* 练习架构（这个是真的一个长期的过程了，需要在项目中不断积累经验）

其次，我觉得对于前端工程师来说，审美也是非常有必要提升的，我有关注很多设计师相关的平台和公众号，经常会去翻阅提升自己的审美水平，然后乐器的话也是有在练习口琴的。

#### 希望加入什么样的团队
对于自身而言：
1. 开心：工作环境良好、团队氛围舒适、人际关心融洽、工作内容及节奏可匹配和胜任等。
2. 成长：工作有所挑战、可以弥补自己的某些短板、可以锻炼更广阔的视野和灵活的思维等。
3. 发挥所长：自己的能力和价值可以得到体现和发挥、可以有机会成为某种权威、可以在擅长的细分领域得到积累等。
4. 希望有相对好的收入

然后是对于团队协作和项目规范来说：（因为一个项目前期规范的程度是和项目易维护程度是呈正比的，对于我来说，是会把时间花在啊规范上面的）

- 统一的项目结构：可能根据不同的类别会有几个，如响应式项目，非响应式项目
- 编码规范
- 高质量的第三方组件库；以及团队自己开发的组件/代码片段
- 丰富的文档，包括 
    - 可在线查看的公共的文档 
        - 第三方组件库；以及团队自己开发的组件/代码片段的文档以及demo
        - 前端工具的介绍
        - 项目开发过程中遇到的问题的描述与总结
    - 具体项目的文档 
        - 项目如何启动
        - 项目文件结构描述
        - 项目的开发和发布
- 工具化 
    - 项目结构由命令行生成
    - 新建页面，模块等由命令行生成
    - 功能完成后，用工具进行验证编码风格是否满足规范
    - 发布流程：资源压缩，合并等
- 维护团队前端技能树。列出我们知道的所有的前端的技术点。并标出团队对技能的熟悉情况。不断的去覆盖它。

#### 项目介绍
这个项目是一个智能开发商车位销售平台，我担任的是项目的一部分开发工作，负责用户模块的整体前后端代码开发，以及最终的软件测试。该项目主要使用了Spring框架实现前后端分离，Ajax实现数据异步传输，Json实现前后端数据交互，使用MySQL作为数据库，SpringMVC和MyBatis作为后端开发框架。

在项目开发过程中，我负责了整体逻辑的构建，包括用例、类、方法流程等的设计。在数据库的搭建方面，我负责了数据库的设计和优化SQL代码，以确保数据存储和访问的效率和准确性。

在用户模块的开发方面，我负责了整个模块的前后端代码开发，包括前端页面的设计和开发，后端业务逻辑的实现和数据传输的实现。同时，我还负责了最终的软件测试，包括单元测试和集成测试，以确保整个系统的功能和性能符合要求。

同时，我们组员在协同开发过程之中使用git来进行项目协同和版本控制，大大挺高了开发效率和减少开发成本。

总体来说，这个项目的目标是为开发商提供一个高效、智能的车位销售平台，使其能够更好地管理和销售车位，并为用户提供更好的购买体验。我在这个项目中的工作，是为实现这个目标做出了贡献。

##### 难点
>一开始没搞懂
>去网上看了个答案
>一试发现这个广为流传的答案是有坑的
>于是自己看 issue
>发现还有一个小细节
>然后解决了
>谁知道还是在某种 edge case有问题
>于是自己看规范看源码，搞定
>后来发现自己用的第三方库上也有此问题，GitHub上提交pr 被合并

回答：
在我参与的这个车位管理的项目，我负责的用户模块中，有一个业务需求是用户与开发商进行车位购买的时候，等待开发商确认后会拟定一份电子合同，而用户需要在这份合同上签字，并且签字的内容是可以让开发商查看的。当时在实现这个签字功能的时候，一开始是在stackoverflow上寻找解决办法，发现广为流传的方法是通过canvas进行绘图，通过在canvas监听鼠标的点击移动事件动态绘制线条和文本来完成签名，但是在回答里并没有给出如何把数据传递给后台，于是就去学习了一下canvas相关的操作，最后把绘制好的图像通过图片流的形式传递给后台的controller中进行操作，因为按照我们的业务流程这个签名签完之后是要跳转到合同查看的那个页面的，所以在后台的controller中接到这个数据流之后的想法就是把它转换成图片然后保存到对应的路径下之后也能查看，但是这样做的后果就是在当前这次服务中没有办法实时查看，因为图片是保存在本地了，在服务器上并没有保存，除非就是重新启动一次服务器，后来的解决方法就是不仅要把图片保存到本地，在跳转到合同查看那个页面时同时也要把图片的数据流传过去，保证实时可以查看，最终就是通过这样解决了这个签字的的问题。

1. 性能问题
   在我参与的企业网站开发项目中，我们使用了一些复杂的UI组件和动画效果，导致网站加载速度变慢。为了解决这个问题，我们使用了Webpack进行代码分割，只加载当前页面所需要的代码，减少了网站的加载时间。同时，我们使用了CDN来加速网站静态资源的加载。此外，我们还对图片进行了优化，使用了懒加载和预加载等技术来提高网站性能。

 |  	 | 懒加载	| 预加载|
 |  ---- | ----  | ---- |
 |  定义	| 延迟加载、按需加载	|提前加载、不需要也提前加载|
 |  目的	|更好更快地加载页面首屏内容，网页性能优化	|让用户无需等待，获得直接预览的良好体验|
 | 缺点	|需要监听图片是否显示，耗费浏览器性能	|占用较多的后台资源，可能一次性加载较多的图片|
 |  应用场景|	电商搜索产品时图片展示	|观看漫画时，每次切换的下一张图片提前加载|

2. 跨域问题
   在我参与的电子商务平台开发项目中，我们前后端分离，前端使用Vue.js作为框架，后端使用Node.js和MongoDB。在前端向后端发送请求时，由于跨域问题，导致请求被浏览器拦截。为了解决这个问题，我们使用了Vue.js提供的代理模式，在开发模式下将前端请求代理到后端。在生产环境下，我们使用了Nginx反向代理来解决跨域问题。

3. 数据库设计问题
   在我参与的微信小程序开发项目中，我们使用了小程序云开发提供的数据库服务。在设计数据库时，我们遇到了一些问题，例如数据结构不合理、查询性能较差等。为了解决这个问题，我们对数据进行了重新设计，使用了适当的索引来提高查询性能。我们还对数据库进行了数据分片，将数据存储在多个集合中，以减少单个集合中的数据量。

以上是我在项目中遇到的一些难点以及解决方法。在实际项目中，我们会遇到各种各样的问题，关键在于能够快速找到问题所在，并采取有效的解决方案。这需要我们具备良好的沟通能力、团队协作能力以及快速学习和解决问题的能力。

1. 前后端数据交互问题：由于是前后端分离的开发模式，需要使用Ajax和Json实现数据交互。在实现过程中，需要考虑如何处理前端发送的请求并返回正确的响应，以及如何在前端页面正确地解析后端返回的数据。
2. 大规模数据存储问题：由于项目需要存储大量的数据，如车位信息、用户信息等，需要考虑如何设计和优化数据库，以确保数据的存储和访问的效率和准确性。
3. 多人协作问题：由于项目需要多人协作开发，需要考虑如何合理地分配任务、协同开发以及如何处理代码冲突等问题，以确保项目能够高效地进行。
针对这些问题，我通过学习相关知识和与团队成员沟通协作，最终解决了这些问题。比如，在前后端数据交互方面，我通过学习相关的技术和与后端开发人员的沟通，成功地实现了数据的正确传输和解析；在数据库设计和优化方面，我使用了相关的工具和技术，如SQL语句的优化等，来提高数据库的性能和准确性；在多人协作方面，我使用了Git等版本控制工具来协同开发和解决代码冲突等问题。


#### SQL优化
1、对查询进行优化，应尽量避免全表扫描；
2、应尽量避免在where子句中对字段进行null值判断；
3、应尽量避免在where子句中使用!=或<>操作符；
4、“in”和“not in”也要慎用，否则会导致全表扫描。
5、对于一些比较复杂，重用度比较高的逻辑会建立触发器来简化代码

#### 测试和开发的区别
开发（SWE）测开（SWT）测试(TE)

- 代码能力要求：SWE=SWT>TE
- 知识广度要求：SWT,TE>SWE
- 沟通能力要求：TE>SWT>SWE
- 知识深度要求：SWE>SWT>TE

角色上：
前端：用户可以看到的，使用界面的，web端，pc端，app，一般是在用户的机器上去做，更注重交互体验一些。
后端：看不到界面，提供前端的数据的，数据增删改查，一般是属于服务器公司的
测试就是要考虑到用户会进行怎么样的操作，把自己当成用户
酒吧测试笑话（用户是邪恶的

计算一般计算放在服务器端，如果放到客户端，客户端的数据可能不是全的，客户端做大量计算，会导致用户的使用体验变差，前端一般做简单的计算和展现

服务器端一般做复杂的计算。所以服务器的测试会更有发展一些。

一般服务器端的测试用到的工具有postman，可以看到返回的请求是什么

服务器端的测试：功能测试，系统的容错性，系统的耦合性，性能测试，稳定性，容量测试，所以服务器端的测试含量会高一些

测试一般是从功能测试入手，会经历白盒测试、黑盒测试、自动化测试等。

#### 加班
进行前端工作是一个非常细致的过程，在我以往的项目经验来看，每一个项目都有一些重要的节点，这需要整个团队都付出额外的努力和时间，对此我表示十分地理解，因为这是我们需要做的核心工作。在我看来，如果加班是必要的，那我愿意投入额外的时间，并推动工作的发展，如果加班是因为其他的情况导致一些工作效率低下造成的，那我会做的是找出效率低下的原因，并找到自己和团队能够改善的方法

作为一个前端工程师，我认为加班是必要的，但是不能成为常态。在项目紧急的情况下，必须要进行加班来满足项目的进度和质量要求，但同时需要合理安排工作和生活，保持身体和心理的健康。如果加班成为常态，可能说明问题出在项目的规划和管理上，需要重新评估项目的进度和资源分配。

在加班时，我认为需要有效地利用时间，合理安排任务，避免无效的加班。同时需要与团队成员充分沟通，合理分配任务，减少因个人原因引起的加班。最后，在加班结束后，需要适当地休息和放松，保持健康的生活方式。

#### bunjs性能
- 不同于 Node.js 和 Deno，Bun 使用了 JavaScriptCore 引擎，其启动和执行速度比 V8 引擎要快一些；
- 使用了新兴的系统编程语言 Zig，主要通过手动内存管理对内存进行更细粒度的控制、无隐藏的控制流来提升程序的性能；
- 在前两点的前提下，重新实现了诸如 JSX/TypeScript 转编器、SQLite 客户端、HTTP 客户端、WebSocket 客户端等类库。

#### core-js简介
core-js是**完全模块化的javascript标准库**。 包含ECMA-262至今为止大部分特性的polyfill，如promises、symbols、collections、iterators、typed arrays、etc，以及一些跨平台的WHATWG / W3C特性的polyfill，如WHATWG URL。 它可以直接全部注入到全局环境里面，帮助开发者模拟一个包含众多新特性的运行环境，这样开发者仅需简单引入core-js，仍然使用最新特性的ES写法编码即可；也可以不直接注入到全局对象里面，这样对全局对象不会造成污染，但是需要开发者单独引入core-js的相关module，并可能还需要通过手工调用module完成编码，没法直接使用最新ES的写法。它是一个完全模块化的库，所有的polyfill实现，都有一个单独的module文件，既可以一劳永逸地把所有polyfill全部引入，也可以根据需要，在自己项目的每个文件，单独引入需要的core-js的modules文件。
#### 问面试官的
- 工作流程
- 常用工具
- 新人培养机制

**职责**

- On-call (电话值班)的计划或者规定是什么？值班或者遇到问题加班时候有加班费吗？
- 我的日常工作是什么？
- 团队里面初级和高级工程师的比例是多少？（有计划改变吗）
- 入职培训会是什么样的？
- 自己单独的开发活动和按部就班工作的比例大概是怎样的？
- 每天预期/核心工作时间是多少小时？
- 在你看来，这个工作做到什么程度算成功？
- 我入职的岗位是新增还是接替之前离职的同事？(是否有技术债需要还)？(zh)
- 入职之后在哪个项目组，项目是新成立还是已有的？(zh)

**技术**

- 公司常用的技术栈是什么?
- 你们怎么使用源码控制系统？
- 你们怎么测试代码？
- 你们怎么追踪 bug?
- 你们怎么集成和部署代码改动？是使用持续集成和持续部署吗？
- 你们的基础设施搭建方法在版本管理系统里吗？或者是代码化的吗？
- 从计划到完成一项任务的工作流是什么样的？
- 你们如何准备故障恢复？
- 有标准的开发环境吗？是强制的吗？
- 你们需要花费多长时间来给产品搭建一个本地测试环境？（分钟/小时/天）
- 你们需要花费多长时间来响应代码或者依赖中的安全问题？
- 所有的开发者都可以使用他们电脑的本地管理员权限吗？
- 公司是否有技术分享交流活动？有的话，多久一次呢？(zh)

**团队**

- 工作是怎么组织的？
- 团队内/团队间的交流通常是怎样的？
- 如果遇到不同的意见怎样处理？
- 谁来设定优先级 / 计划？
- 如果被退回了会怎样？（“这个在预计的时间内做不完”）
- 每周都会开什么类型的会议？
- 产品/服务的规划是什么样的？（n周一发布 / 持续部署 / 多个发布流 / ...)
- 生产环境发生事故了怎么办？是否有不批评人而分析问题的文化？
- 有没有一些团队正在经历还尚待解决的挑战？
- 公司技术团队的架构和人员组成？(zh)

**公司**

- 有没有会议/旅行预算？使用的规定是什么？
- 晋升流程是怎样的？要求/预期是怎样沟通的？
- 技术和管理两条职业路径是分开的吗？
- 对于多元化招聘的现状或者观点是什么？
- 有公司级别的学习资源吗？比如电子书订阅或者在线课程？
- 有获取证书的预算吗？
- 公司的成熟度如何？（早期寻找方向 / 有内容的工作 / 维护中 / ...)
- 我可以为开源项目做贡献吗？是否需要审批？
- 有竞业限制或者保密协议需要签吗？
- 你们认为公司文化中的空白是什么？
- 能够跟我说一公司处于不良情况，以及如何处理的故事吗？

**商业**

- 你们现在盈利吗？
- 如果没有的话，还需要多久？
- 公司的资金来源是什么？谁影响或者指定高层计划或方向？
- 你们如何挣钱？
- 什么阻止了你们挣更多的钱？
- 你们认为什么是你们的竞争优势？

**远程工作**

- 远程工作和办公室工作的比例是多少？
- 公司提供硬件吗？更新计划如何？
- 额外的附件和家居可以通过公司购买吗？这方面是否有预算？
- 有共享办公或者上网的预算吗？
- 多久需要去一次办公室？
- 公司的会议室是否一直为视频会议准备着？

**办公室工作**

- 办公室的布局如何？（开放的 / 小隔间 / 独立办公室）
- 有没有支持/市场/或者其他需要大量打电话的团队在我的团队旁边办公？
- 待遇
- 如果有奖金计划的话，奖金如何分配？
- 如果有奖金计划的话，过去的几年里通常会发百分之多少的奖金？
- 有五险一金或者其他退休养老金等福利吗？如果有的话，公司有配套的商业保险吗？

**带薪休假**

- 带薪休假时间有多久？
- 病假和事假是分开的还是一起算？
- 我可以提前使用假期时间吗？也就是说应休假期是负的？
- 假期的更新策略是什么样的？也就是说未休的假期能否滚入下一周期
- 照顾小孩的政策如何？
- 无薪休假政策是什么样的？

### 恒生一面

#### 自我介绍

#### 项目经历，以及怎么实现
   1. 项目的背景是什么
   2. 当前项目的目的是什么
   3. 在开发过程中，我的角色是什么
   4. 在开发过程中遇到什么难题
   5. 遇到这些问题都是怎么解决的
   6. 项目完成后取得了哪些成果

#### 项目中的难点以及怎么解决
   * 业务/技术
   * 翻页需求（SQL和前端适配）
通过传入参数，限制页数和每页的数量
```xml
   <select id="selectOrder" parameterType="java.util.Map" resultType="com.bean.Order">
        select `order`.* from `order`,`parking_space`,`residential_quarters`
    <where>
        `order`.parking_space_id=`parking_space`.id and
        `parking_space`.residential_quarters_id = `residential_quarters`.id and
        `residential_quarters`.developer_id=#{did}
        <if test="search != null and search !=''">
            and `order`.`state` like concat('%', #{search}, '%')
            or `order`.`order_time` like concat('%', #{search}, '%')
            or `order`.`order_id` = #{search}
        </if>
    </where>
    LIMIT ${(pageNum-1)*pageSize},${pageSize*pageNum};
    </select>
```
   * 跟被人协作时 git问题等等
   * youtube上那个展开

#### 使用什么框架，vue的生命周期以及其对应构造函数

#### 跟他人协调，以及遇到的困难。

#### 闭包

闭包是指一个函数可以访问并操作在其定义外部的变量，即使这个函数在外部变量的作用域之外被调用，也能访问到这些变量。这是因为在JavaScript中，每个函数都会创建一个自己的作用域，包括函数中定义的局部变量和函数的参数，以及在函数定义时在外部作用域中定义的变量。

当一个函数内部引用了在外部作用域中定义的变量时，JavaScript会自动创建一个闭包来保存这个变量的引用。闭包是由函数和其对应的作用域组成的，它可以在函数外部访问并操作在函数定义时存在的作用域中的变量。这种机制可以让JavaScript中的函数具有更大的灵活性和可重用性。

例如，以下代码演示了如何创建和使用闭包：

function createCounter() {
  var count = 0;
  function counter() {
    count++;
    console.log(count);
  }
  return counter;
}

var myCounter = createCounter();
myCounter(); // 输出 1
myCounter(); // 输出 2

在这个例子中，createCounter 函数返回一个内部函数 counter。counter 内部引用了在外部作用域中定义的 count 变量。当 myCounter 被调用时，count 变量的值被增加，并输出到控制台。由于 myCounter 是 createCounter 返回的 counter 函数，它可以访问并操作 createCounter 定义时存在的作用域中的变量，也就是闭包的概念。

#### this关键字

在JavaScript中，this 关键字指向当前函数的执行上下文，它的值在每个函数调用时动态计算，具体取决于函数被调用时的调用方式以及执行上下文的类型。 this 的值在运行时确定，而不是在函数定义时确定。

this 的值在 JavaScript 中有四种调用方式：

1. 默认绑定：当一个函数独立调用时，this 指向全局对象，即 window 对象。

2. 隐式绑定：当一个函数作为对象的方法调用时，this 指向调用该方法的对象。

3. 显式绑定：通过 call()、apply() 或者 bind() 方法将一个函数绑定到指定对象上，并且 this 指向指定对象。

4. new 绑定：通过 new 关键字创建一个新的实例对象时，this 指向这个新对象。


另外，作用域是指一个变量的可访问范围。在 JavaScript 中，有函数作用域和块级作用域两种作用域。函数作用域指的是在函数内部定义的变量只在该函数内部可见，而在函数外部无法访问。块级作用域是指在代码块内定义的变量只在该代码块内可见。

当一个函数被调用时，它会创建一个新的执行上下文，这个执行上下文包含了当前函数的作用域以及 this 的值。函数内部可以访问当前作用域和上层作用域中定义的变量，但是不能访问函数外部的作用域中定义的变量。在 JavaScript 中，作用域链用来描述一个函数在执行时如何访问变量的，它是由当前函数的作用域以及上层作用域构成的。

总结一下，this 关键字用于确定当前函数的执行上下文，作用域用于确定一个变量的可访问范围。在 JavaScript 中，要理解好 this 和作用域，可以帮助我们写出更加清晰和可维护的代码。

#### 有什么要问面试官的
   * 觉得我怎么样
   * 总共几轮面试
   * 团队用的技术栈
   * 团队的人员架构
   * 团队协作工具/开发工具/流程工具是什么，如何沉淀文档
   * 未来团队计划补充到多少人

### 杭州银行（总行信息技术部-前端）
#### 自我介绍
#### 关注前端的哪些事件
#### 介绍一下core-js
>core-js是完全模块化的javascript标准库。 包含ECMA-262至今为止大部分特性的polyfill，如promises、symbols、collections、iterators、typed arrays、etc，以及一些跨平台的WHATWG / W3C特性的polyfill，如WHATWG URL。 **它可以直接全部注入到全局环境里面，帮助开发者模拟一个包含众多新特性的运行环境，这样开发者仅需简单引入core-js，仍然使用最新特性的ES写法编码即可；**也可以不直接注入到全局对象里面，这样对全局对象不会造成污染，但是需要开发者单独引入core-js的相关module，并可能还需要通过手工调用module完成编码，没法直接使用最新ES的写法。它是一个完全模块化的库，所有的polyfill实现，都有一个单独的module文件，既可以一劳永逸地把所有polyfill全部引入，也可以根据需要，在自己项目的每个文件，单独引入需要的core-js的modules文件。

#### 介绍项目
#### vue生命周期
* beforeCreate: 实例刚被创建，数据观测和事件机制未初始化，此时无法访问到 data、methods、computed 等属性和方法。
* created: 实例已经创建完成，此时已经完成了数据观测和事件机制的初始化，可以访问到 data、methods、computed 等属性和方法。
* beforeMount: 模板编译完成，但未挂载到 DOM 上。
* mounted: 模板编译完成，已经挂载到 DOM 上，此时可以访问到渲染后的 DOM。
* beforeUpdate: 数据更新前，DOM 尚未重新渲染。
* updated: 数据更新后，DOM 已经重新渲染。
* beforeDestroy: 实例销毁前，此时实例仍然可用。
* destroyed: 实例已经销毁，此时实例中的所有东西都已被清理掉。
![image-20230301150128879](image/image-20230301150128879.png)

#### js类型
>值类型(基本类型)：字符串（String）、数字(Number)、布尔(Boolean)、空（Null）、未定义（Undefined）、Symbol。
>引用数据类型（对象类型）：对象(Object)、数组(Array)、函数(Function)，还有两个特殊的对象：正则（RegExp）和日期（Date）。
>注：Symbol 是 ES6 引入了一种新的原始数据类型，表示独一无二的值。

#### 哈希表

数组的特点是：寻址容易，插入和删除困难；

而链表的特点是：寻址困难，插入和删除容易。

应用：

1、Hash主要用于信息安全领域中加密算法，它把一些不同长度的信息转化成杂乱的128位的编码,这些编码值叫做Hash值. 也可以说，Hash就是找到一种数据内容和数据存放地址之间的映射关系。

2、查找：哈希表，又称为散列，是一种更加快捷的查找技术。我们之前的查找，都是这样一种思路：集合中拿出来一个元素，看看是否与我们要找的相等，如果不等，缩小范围，继续查找。而哈希表是完全另外一种思路：当我知道key值以后，我就可以直接计算出这个元素在集合中的位置，根本不需要一次又一次的查找！

举一个例子，假如我的数组A中，第i个元素里面装的key就是i，那么数字3肯定是在第3个位置，数字10肯定是在第10个位置。哈希表就是利用利用这种基本的思想，建立一个从key到位置的函数，然后进行直接计算查找。

3、Hash表在海量数据处理中有着广泛应用。

#### 数据结构有哪些

https://hit-alibaba.github.io/interview/basic/algo/Hash-Table.html

* 数组（Array）
* 队列（Queue）
* 链表（Linked List）
* 栈（Stack）
* 树（Tree）
* 散列表（Hash）
* 堆（Heap）
* 图（Graph）

##### 数组(Array)
数组是最简单、使用最频繁的一种数据结构。它一种线性表数据结构，用一组连续的内存空间来存储一组相同类型的数据。

![image-20230302115519132](image/image-20230302115519132.png)

##### 队列(Quene)

队列也是一种非常基础的数据结构，其特点是先入先出，也就是我们常听到的FIFO（First in First Out），即操作数据是从两端进行的。

![image-20230302115628865](image/image-20230302115628865.png)

##### 链表(Linked List)

链表是一种物理存储单元上非连续，非顺序的存储结构。链表有一系列节点组成，所谓节点就是指链表中的每一个元素，每个节点包含两个数据，一个是存储元素的数据域（值），另一个是存储下一个节点地址的指针域。

![image-20230302115702717](image/image-20230302115702717.png)

通俗点说，链表数据一般都是分散存储于内存中 的，无须存储在连续空间内。这样大家可能还不能直观的感受链表的非连续，我再画一张图：

![image-20230302120103857](image/image-20230302120103857.png)

假设上图中100-108是一块内存中连续地址的内存分布，假设101、103、106、107这几个内存地址都已经存储数据了，那剩下的100、102、104、105、108是不是就浪费呢，答案是否定的，我们可以使用链表的方式存储数据。

##### 栈(Stack)

栈也是一种数据呈线性排列的数据结构，和上面的队列相反，栈的特点先进后出、后进先出，就是常说的LIFO（Last in First Out）。

![image-20230302120356051](image/image-20230302120356051.png)

##### 树(Tree)

树形结构是一种层级式的数据结构，由顶点（节点）和连接它们的边组成。
数的结构特点是：

- 每个节点有零个或多个子节点；
- 没有父节点的节点称为根节点；
- 每一个非根节点有且只有一个父节点；
- 除了根节点外，每个子节点可以分为多个不相交的子树。

我们平时用到最多的就是二叉树，我也以二叉树来为例，先看一下树结构：

![image-20230302120523184](image/image-20230302120523184.png)

二叉树有几下特点：

- 每个结点最多有两颗子树，结点的度最大为2。
- 左子树和右子树是有顺序的，次序不能颠倒。
- 即使某结点只有一个子树，也要区分左右子树。
- 个结点的值均大于其左子树上任意一个结点的值。比如 点的值。结点100大于其左子树上的30，18和16。
- 每个结点的值均小于其右子树上任意 一个结点的值。比如结点 100 小于其右子树上的 120、130 和 135。

##### 散列表(Hash)

散列表又叫哈希表，存储的是由键(key)和值(value)组 成的数据，根据键直接访问存储在内存存储位置的数据结构。

![image-20230302120644443](image/image-20230302120644443.png)

从图中可以看出，左边很明显是个数组，数组的每个成员包括一个指针，指向一个链表的头，当然这个链表可能为空，也可能元素很多。我们根据元素的一些特征把元素分配到不同的链表中去，也是根据这些特征，找到正确的链表，再从链表中找出这个元素。**哈希表查找数据的公式为：记录的存储位置=f(key)**这里的对应关系 f 成为散列函数，又称为哈希 (hash函数)，而散列表就是把Key通过一个固定的算法函数既所谓的哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里，这种存储空间可以充分利用数组的查找优势来查找元素，所以查找的速度很快。我们将在后面详细讲解哈希表数据结构。

##### 堆(Heap)

堆比较特殊，是一种图的树形结构。被用于实现“优先队列”(priority queues)，优先队列是一种数据结构，可以自由添加数据，但取出数据时要从最小值开始按顺 序取出。在堆的树形结构中，各个顶点被称为“结点”(node)，数据就存储在这些结点中。
只要满足下面两个特点的树形结构就是堆：

- 堆是一个完全二叉树（所谓完全二叉树就是除了最后一层其他层的节点个数都是满的）。
- 堆中每一个节点的值都必须大于等于或者小于其子树中每一个节点的值。

下面我们看一下堆的结构：

![image-20230302132123031](image/image-20230302132123031.png)

上面其实叫大顶堆，如果每一个节点小于子树中每个节点的值，那就叫小顶堆。

##### 图(Graph)

图是相对复杂的一种数据结构，由顶点和连接每对顶点的边所构成的图形就是图。
我们先来看图：

![image-20230302132205176](image/image-20230302132205176.png)

上图中的圆圈叫作“顶点”(Vertex，也叫“结点”)，连接顶点的线叫作“边”（Edge）。也就是说，由顶点和连接每对顶点的边所构成的图形就是图。 图按照顶点指向的方向可分为无向图和有向图，像我上面的就叫无向图。 图在存储数据上有着比较复杂和高效的算法，分别有邻接矩阵 、邻接表、十字链表、邻接多重表、边集数组等存储结构。常见的图遍历算法就是广度优先算法和深度优先算法。


#### 原子性
>数据库管理系统中事务(transaction)的四个特性（分析时根据首字母缩写依次解释）：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）
>所谓事务，它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。（执行单个逻辑功能的一组指令或操作称为事务）
>1. 原子
>>原子性是指事务是一个不可再分割的工作单元，事务中的操作要么都发生，要么都不发生。
>>可采用“A向B转账”这个例子来说明解释
>>在DBMS中，默认情况下一条SQL就是一个单独事务，事务是自动提交的。只有显式的使用start transaction开启一个事务，才能将一个代码块放在事务中执行。
>2. 一致性
>>一致性是指在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。这是说数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。
>>如A给B转账，不论转账的事务操作是否成功，其两者的存款总额不变（这是业务逻辑的一致性，至于数据库关系约束的完整性就更好理解了）。
>>保障机制（也从两方面着手）：数据库层面会在一个事务执行之前和之后，数据会符合你设置的约束（唯一约束，外键约束,check约束等)和触发器设置；此外，数据库的内部数据结构（如 B 树索引或双向链表）都必须是正确的。业务的一致性一般由开发人员进行保证，亦可转移至数据库层面。
>3. 隔离性
>>多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。
>>在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看到中间状态的数据。
>>事务最复杂问题都是由事务隔离性引起的。完全的隔离性是不现实的，完全的隔离性要求数据库同一时间只执行一条事务，这样会严重影响性能。
>>关于隔离性中的事务隔离等级（事务之间影响），参见相应博文
>4. 持久性
>>这是最好理解的一个特性：持久性，意味着在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。（完成的事务是系统永久的部分，对系统的影响是永久性的，该修改即使出现致命的系统故障也将一直保持）
>>write ahead logging：SQL Server中使用了WAL（Write-Ahead Logging）技术来保证事务日志的ACID特性，在数据写入到数据库之前，先写入到日志，再将日志记录变更到存储器中。

#### 数据库建立索引要在哪些建立
索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。
>1. 在经常搜索的列上创建索引，能够加快搜索的速度；
>2. 在作为主键的列上创建索引，需要强制该列的唯一性和组织表中数据的排列结构；
>3. 在经常被用在连接的列上(主要是外键)建立索引，可以加快连接速度。
>4. 在经常使用WHERE子句的列上建立索引，加快条件的判断速度。当增加索引时，会提高检索性能，加快条件的判断速度，但是会降低修改性能。
>
>参考：https://cloud.tencent.com/developer/article/1769263

#### 为什么要选择杭州银行
我非常感谢您提出这个问题。我选择杭州银行，主要是基于以下几点原因：

首先，杭州银行是一家具有良好声誉和潜力的金融机构，其稳定的发展和创新的精神吸引了我。随着金融科技的快速发展，杭州银行也在不断地推出新的数字化服务，这些服务为客户提供了更高效、便捷、安全的银行服务，同时也带动了金融科技的发展。作为一名前端开发人员，我希望能够参与这个领域的创新，并为银行的数字化转型贡献自己的力量。

其次，我对杭州这个城市也有着浓厚的兴趣。作为一个有着丰富历史和文化底蕴的城市，杭州有着许多美丽的景点和富有活力的社区。在这个城市工作和生活，我相信可以感受到它的多元化和包容性，并且拥有更多的机会与人们进行交流和互动。

最后，我相信杭州银行可以为我提供一个良好的职业发展平台。作为一家金融机构，杭州银行有着完善的组织架构和职业发展路径，它也注重培养员工的技能和知识，为员工提供了广泛的培训和晋升机会。我希望能够成为杭州银行信息技术部的一员，与公司一起成长和发展，创造更多的价值。
#### v2 v3 的差别
>(https://worktile.com/kb/ask/19553.html)
>vue2和vue3的区别有以下8点：1、双向数据绑定原理不同；2、是否支持碎片；3、API类型不同；4、定义数据变量和方法不同；5、生命周期钩子函数不同；6、父子传参不同；7、指令与插槽不同；8、main.js文件不同。
>
>1. 双向数据绑定原理不同
>>vue2：vue2的双向数据绑定是利用ES5的一个APIObject.definePropert() 对数据进行劫持，结合发布订阅模式的方式来实现的。
>>vue3：vue3中使用了ES6的Proxy API对数据代理。相比vue2.x，使用proxy的优势如下：
>>
>>* defineProperty只能监听某个属性，不能对全对象监听
>>* 可以省去for in，闭包等内容来提升效率(直接绑定整个对象即可)
>>* 可以监听数组，不用再去单独的对数组做特异性操作vue3.x可以检测到数组内部数据的变化。
>
>2. 是否支持碎片
>>vue2：vue2不支持碎片。
>>vue3：vue3支持碎片（Fragments），就是说可以拥有多个根节点。
>
>3. API类型不同
>>vue2：vue2使用选项类型api，选项型api在代码里分割了不同的属性：data,computed,methods等。
>>vue3：vue3使用合成型api，新的合成型api能让我们使用方法来分割，相比于旧的api使用属性来分组，这样代码会更加简便和整洁。
>
>4. 定义数据变量和方法不同
>>vue2：vue2是把数据放入data中，在vue2中定义数据变量是data(){}，创建的方法要在methods:{}中。
>>vue3：，vue3就需要使用一个新的setup()方法，此方法在组件初始化构造的时候触发。使用以下三个步骤来建立反应性数据： 
>>* 从vue引入reactive；
>>* 使用reactive() 方法来声明数据为响应性数据；
>>* 使用setup()方法来返回我们的响应性数据，从而template可以获取这些响应性数据。
>
>5. 生命周期钩子函数不同
>>vue2：vue2中的生命周期：
>>* beforeCreate 组件创建之前
>>* created 组件创建之后
>>* beforeMount 组价挂载到页面之前执行
>>* mounted 组件挂载到页面之后执行
>>* beforeUpdate 组件更新之前
>>* updated 组件更新之后
>
>>vue3：vue3中的生命周期：
>>* setup 开始创建组件
>>* onBeforeMount 组价挂载到页面之前执行
>>* onMounted 组件挂载到页面之后执行
>>* onBeforeUpdate 组件更新之前
>>* onUpdated 组件更新之后
>
>>而且vue3.x 生命周期在调用前需要先进行引入。除了这些钩子函数外，vue3.x还增加了onRenderTracked 和onRenderTriggered函数。
>
>6. 父子传参不同
>>vue2：父传子，用props,子传父用事件 Emitting Events。在vue2中，会调用this$emit然后传入事件名和对象。
>>vue3：父传子，用props,子传父用事件 Emitting Events。在vue3中的setup()中的第二个参数content对象中就有emit，那么我们只要在setup()接收第二个参数中使用分解对象法取出emit就可以在setup方法中随意使用了。
>
>7. 指令与插槽不同
>>vue2：vue2中使用slot可以直接使用slot；v-for与v-if在vue2中优先级高的是v-for指令，而且不建议一起使用。
>>vue3：vue3中必须使用v-slot的形式；vue3中v-for与v-if,只会把当前v-if当做v-for中的一个判断语句，不会相互冲突；vue3中移除keyCode作为v-on的修饰符，当然也不支持config.keyCodes；vue3中移除v-on.native修饰符；vue3中移除过滤器filter。
>
>8. main.js文件不同
>>vue2：vue2中我们可以使用pototype(原型)的形式去进行操作，引入的是构造函数。
>>vue3：vue3中需要使 用结构的形式进行操作，引入的是工厂函数；vue3中app组件中可以没有根标签。





### 华电电话面
#### const和let的区别
https://www.freecodecamp.org/chinese/news/javascript-var-let-and-const/
* var声明是全局作用域或函数作用域，而let和const是块作用域。
* var变量可以在其范围内更新和重新声明； let变量可以被更新但不能重新声明； const变量既不能更新也不能重新声明。
* 它们都被提升到其作用域的顶端。但是，虽然使用变量undefined初始化了var变量，但未初始化let和const变量。
* 尽管可以在不初始化的情况下声明var和let，但是在声明期间必须初始化const。

#### GET 和 POST 的区别。
- 从缓存的角度，GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。
- 从编码的角度，GET 只能进行 URL 编码，只能接收 ASCII 字符，而 POST 没有限制。
- 从参数的角度，GET 一般放在 URL 中，因此不安全，POST 放在请求体中，更适合传输敏感信息。
- 从幂等性的角度，GET 是幂等的，而 POST 不是。(幂等表示执行相同的操作，结果也是相同的)
- 从 TCP 的角度，GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分。(火狐浏览器除外，它的 POST 请求只发一个 TCP 包)

#### cookie和session的区别
https://www.51cto.com/article/679219.html

- 作用范围不同，Cookie 保存在客户端(浏览器)，Session 保存在服务器端。
- 存取方式的不同，Cookie只能保存 ASCII，Session可以存任意数据类型，比如UserId等。
- 有效期不同，Cookie可设置为长时间保持，比如默认登录功能功能，Session一般有效时间较短，客户端关闭或者Session超时都会失效。
- 隐私策略不同，Cookie存储在客户端，信息容易被窃取;Session存储在服务端，相对安全一些。
- 存储大小不同， 单个Cookie 保存的数据不能超过 4K，Session可存储数据远高于Cookie。


#### css id和name，什么时候用id，什么时候用name
https://www.jianshu.com/p/246ad0659e2a
#### 数据库：编号 时间 钱，编写一条sql找最多。

### 泰隆银行一面（视频）
#### 自我介绍
#### 项目的角色
#### 为什么要做这个项目
#### 数据库设计（表）
#### 遇到的难点
#### 前端的适配问题

### 肖邦一面（电话面）
#### 1. js的数据类型和数据类型的判断方法
- 基本数据类型
	- number
	- String
	- boolean
	- Null
	- Undefined
	- BigInt（ES6新增）
	- Symbol（ES6新增）
- 引用数据类型
	- Object
	- Array
	- Function
	- Date

##### 判断方法
- typeof
	- typeof方法可以准确判断除了null之外的所有的基本数据类型**（注：typeof null // "object" 是javascript这门语言的历史遗留问题，需要记忆）**，其他的六种数据类型都可以准确判断，所以我们可以用**（typeof 变量 === “undefined”）**来判断一个变量是否被声明，但是引用数据类型typeof只能判断出函数类型，其他引用类型都返回‘object’。所以通常用typeof来判断**基本数据类型**
- instanceof
	- instanceof 运算符是用来判断一个对象是否在其原型链原型构造函数的属性，所以在比较对象（引用类型）时才有意义，不能判断值类型，但是引用类型可以，值得注意的是arr和obj在instanceof Object的时候的值都是true，这就导致判断是对象时不准确，**因为instanceof 是用于检测构造函数（右边）的 prototype 属性是否出现在某个实例对象（左边）的原型链上。**
- constructor
	- undefined和null没有constructor属性，所以判断时代码可能会报错--这很致命，会导致代码运行不下去，所以只有在确定待判断的值不是undefined和null才能使用
	- 由于constructor属性是可以变更的，也会导致检测出的结果不正确
- Object.prototype.toString.call();（通用完美的解决方法）
	- Object.prototype.toString.call()方法，它的返回值是"[ object , 类型]"（注：返回值前面是小写字母，后面是大写字母开头的类型），可以识别出javascript这门语言中所有的数据类型



#### 2. 判断一个值是否为数组
在数组身上有一种isArray方法可以判断是否为数组类型数据，返回值是布尔类型（true || false）（在其他语言中arr2 = [1, 'abc', true]严格意义上不算数组，但是在javascript中属于数组 ）

![image-20230313190651326](image/image-20230313190651326.png)

#### 3. 数组自带的map,find等，把知道的遍历数组的方法都列举一下
- foreach
	- https://juejin.cn/post/6957604908052938783
- for...in/for...of
	- for...in...会遍历私有属性、原型属性 for...of...走的是Symbol.Interator接口，数组本身自带
- map
	- 和forEach类似
	- 相同：不改变原数组
	- 区别：map会返回新数组；forEach无返回值（undifined）
- reduce
	- 回调函数第一次执行时， x 和y的取值有两种情况： 如果调用reduce()时提供了initialValue，x取值为initialValue，y取数组中的第一个值； 如果没有提供 initialValue，那么x取数组中的第一个值，y取数组中的第二个值。
- filter
	- 过滤
- every/some
	- some方法：对数组的每一项运行回调函数，有一项返回true，就返回true
	- every方法：对数组的每一项运行回调函数，每一项都返回true，才返回true
- find/findIndex/includes/indexOf/lastIndexOf
	- find:(返回第一个符合要求的元素值)
	- findIndex:(返回第一个符合要求的元素下标)
	- includes:是否包含，返回true/false
	- indexOf：有则返回第一个符合要求的元素下标，没有则返回-1
	- lastIndexOf：有则返回最后一个符合要求的元素下标，没有则返回-1


#### 4. 这些方法有什么区别
上文介绍
#### 5. var const let 区别
var会将变量提升到最开始声明，但不会赋值

const和let不会提升

##### 暂时性死区
let/const会被先创建出来，但未被绑定值，所以不能用。

好习惯：不要再let/const声明前使用变量，用了就触发暂时性死区。

```js
a = 100;//触发暂时性死区
let a = 20;
```
let声明的变量可以改变，值和类型都可以改变；const声明的常量不可以改变，这意味着，const一旦声明，就必须立即初始化，不能以后再赋值
**数组和对象等复合类型的变量，变量名不指向数据，而是指向数据所在的地址。const只保证变量名指向的地址不变，并不保证该地址的数据不变，所以将一个复合类型的变量声明为常量必须非常小心。**


#### 6. 箭头函数了解吗，和普通函数的区别
- 箭头函数与普通函数相比，缺少了caller，arguments，prototype
- 1. 声明方式不同，匿名函数
	- 声明一个普通函数需要使用关键字function来完成，并且使用function既可以声明成一个具名函数也可以声明成一个匿名函数
	- 声明一个箭头函数则只需要使用箭头就可以，无需使用关键字function，比普通函数声明更简洁。
	- 箭头函数只能声明成匿名函数，但可以通过表达式的方式让箭头函数具名
- 2. this指向不同
	- 首先第一个方面是 **普通函数的 this 指向**：针对于普通函数而言，`this` 指向调用方。
	- 然后是箭头函数：针对于箭头函数而言，不会修改 `this` 指向，即 **this 指向上层作用域中的 this** 
	- 最后是 `call、apply、bind` 这三个 `API`：它们都可以在 **普通函数** 中修改 `this` 指向，`this` 指向它们的第一个参数
- 3. 箭头函数没有原型prototype
- 4. 箭头函数不能当成一个构造函数

```js
function Person(name) {
  // this 指向实例对象
  this.name = name
}
const p = new Person('张三')
console.log(p); // Person {name: '张三'}


const Person2 = (name) => {
  // this 指向 window
  this.name = name
}
const p2 = new Person2('张三')
console.log(p2); // Uncaught TypeError: Person2 is not a constructor
```

- 5. 关于剩余参数： **使用 rest 参数替代 arguments 关键字** 来获取剩余参数


#### 7. promise清楚吗
作用：解决回调地狱
语法上：promise是一个构造函数
简单来说，promise对象用来封装一个异步操作并可以获取其结果
#### 8. 事件循环

#### 9. 深拷贝和浅拷贝区别
浅拷贝：新建一个指针指向该内存地址，修改的是同一个值
深拷贝：复制多一份内存地址，新建一个指针指向新的内存地址，修改的是各自的值
#### 10. 实现深拷贝的方法
拷贝出来的对象不影响原对象

```js
function deepclone(obj){
	//return JSON.parse(JSON.stringify(obj));//function、正则、事件对象等很多东西都不会复制
	if(typeof obj !== "object" || obj == null){
		return obj;
	}
	let res = obj instanceof Array ? [] : ();
	
	for(let key in obj){
		if(obj.hasOwnProperty(key)){
			res[key] = deepClone(obj[key]);//递归调用，清除循环引用
		}
	}
	return res;
}
```
#### 11. json.parse进行深拷贝有使用吗
//return JSON.parse(JSON.stringify(obj));//function、正则、事件对象等很多东西都不会复制
#### 12. 还有什么想问的吗
##### 前后端配比
前端：后端 => 1：1.5
##### 团队技术栈
vue


### 熙牛医疗
#### 自我介绍

#### 开源提交过代码，什么样的项目

#### 对前端的的理解
前端工程师的主要工作就是通过代码方式，增强系统的交互功能 ，同时结合后台开发技术，进行互联网的 Web 和 App 开发，致力于通过技术改善用户体验 。现在前端工程师的工作不仅仅只是网页制作，还有微网站、APP制作、游戏制作等，前端的技术也慢慢的从原来的 HTML+CSS+JavaScript 愈来愈丰富，如 jquery、Vue、React 等。

前端开发工程师在整个项目的开发和交付中扮演相当重要的角色，前端工程师是最贴近用户的程序员，主要负责实现页面交互，优化提升用户体验，如果后端是用来解决系统能不能用的问题，那么前端就用来解决系统好不好用的问题。
后端：业务逻辑
前端：交互
测试：站在用户的角度看问题
#### 为什么还会选择前端
兴趣
回馈相对直观 
跟java对比（做了一个利用pom本地文件内容检索的应用，前台界面是用java的swing来编写的，就是jetbrain的产品用的那个（idea,webstorm那些），虽然不影响使用啦，但看起来真的有点丑🤣）
像做的好看的编译器比如vscode，就是用electron做的，windows qq用electron做的重构版最近也要发布了，有点期待的。
然后就是前端的扩展性很高啊，新技术一直不断出现，，从jquery到react到vue，然后现在在所谓的大前端概念，用node写后台，在国外js的占有率是最高的，，还有最新的bun.js，说是性能是node的四倍以上，还有像之前元年宇宙比较火的时候跟着火的rust语言，反正就是可扩展性比较高。
#### 之前的的经历中遇到比较有挑战的问题

#### 代码协同应该如何去去解决

#### 生活中比较印象深刻的挑战

#### 通过怎么样的方式去调节

#### 学习前端相关的方面怎么学习的

#### 总结过es6和es5之间的区别吗

#### js数据类型

#### null和undefined区别
##### 什么是undefined
- 全局属性 `undefined` 表示原始值 `undefined`。它是一个 `JavaScript` 的原始数据类型。

- 一个没有被赋值的变量是 `undefined` 类型。

- 如果正在执行的变量没有分配值,则该 方法 或者 语句返回`undefined`。请查看下图:

- ![image-20230318185415120](image/image-20230318185415120.png)

- 在上图中,声明变量返回的是 `undefined`,而 `typeof` 返回的是类型字符串。

- 如果一个函数没有返回值,那么该函数的返回结果是 `undefined`。

- 如果函数定义了有参数,但是没有函数调用参数,那么它也是 `undefined`。

- 为了证明以上的说法,请看下列代码:

```js
  function foo(x, y) {
    console.log(x); // 77
    console.log(y); // undefined
  }
  
  const bar = foo(77);
  console.log(bar); // undefined
```

##### 什么是null
- 值 null 特指对象的值未设置,它是 JavaScript 基本类型之一,在布尔值运算中被认为是 falsy。
- 值 null 是一个字面量,不像 undefined,它不是全局对象的一个属性,指示变量未指向任何对象,把 null 作为尚未创建的对象也许更好理解。从逻辑上讲,null 表示一个空对象指针,这也是给 typeof 传一个 null 会返回 "object"的原因
- 在获取 DOM 元素时,如果没有获取到,返回的是 null,原型链的最顶端也是 null,请看代码:
```js
console.log(document.querySelector("moment")); // null

function foo() {}
console.log(foo.__proto__.__proto__.__proto__); // null
console.log(Object.__proto__.__proto__.__proto__); // null
```

##### 重头戏
- 在 typeof 中分别对 undefined和null进行类型检查,请看以下代码:
```js
console.log(typeof undefined); // undefined
console.log(typeof null); // object
```
- `typeof undefined` 输出 "undefined"估计已经家喻户晓了吧,但是为什么 `typeof null` 输出的 "object",通过查阅资料得知,这是一个历史遗留问题,曾经有有一个 `ECMAScript` 的修复提案,但被拒绝了,这个似乎无法修复,因为它会破坏现有代码(此项目依靠该bug运行...)。
- 在 `JavaScript` 的第一个版本中,值存储在32位的单元中(相当于一条机器码),它由一个小型类型标记(1-3位)和值的实际数据组成。类型标记存储在单元的低位,其中:
	- 000: 对象,数据是对象的引用;
    - 1: 整型,数据是31位带符号的整数;
    - 010: 双精度,数据是双精度浮点数的引用;
    - 100:字符串,数据是字符串;
    - 110: 布尔值,数据是布尔值;
```
在 V8 引擎中,会把 JavaScript 热点代码编译成机器码,它是电脑CPU直接读取运行的机器码，运行速度最快，但是非常晦涩难懂，同时也比较难编写；机器码就是计算机可以直接执行，并且执行速度最快的代码；
```
- 而 `undefined` 和 `null` 是特殊的:
	- undefined:是整数 (-2)^30(超出整数的范围的数字);
	- null: 是机器代码 NULL 指针,或者说是一个对象类型标记加上一个为 0 的引用;
- 好了,绕了这么远,该回来了,还是这个问题,为什么 typeof null 返回的是 "object",这下子应该就很好理解了吧。
- 因为对象的类型标签是 0,由于 `null` 代表的是 空指针,在 `JavaScript` 中没有指针的概念,所以 `null` 32位全为 0 来表示。因此,`typeof null` 返回的是 "object"。
- 所以通过上面的总结, null 本质上是 0,请看以下代码示例:
```js
console.log(undefined + 1); // NaN
console.log(null + 1); // 1
```
- `null` 转化为 `number` 类型时,会转换为 0。
- `undefined` 转换为 `number` 类型时,会转换为 `NaN`。
- 那么使用上还有什么样的区别呢?继续上代码:
```js
function foo(x = 77, y = "moment") {
  console.log(x); // 77
  console.log(y); // null
}

foo(undefined, null);

const [x = 1, y = 2] = [undefined, null];
console.log(x); // 1
console.log(y); // null
```

#### 如果用全等判断是什么结果
```js
console.log(undefined == null);//true
console.log(undefined === null);//false
```

![image-20230318194942418](image/image-20230318194942418.png)

![image-20230318195042023](image/image-20230318195042023.png)

#### 数组的一些操作，假设有一个空的数组，给数组增加一个元素
https://juejin.cn/post/6844904004703485966
array.push() 方法
```js
const names = ['小智']
names.push('前端小智')
names // ["小智", "前端小智"]
```
#### 新增的元素前面再增加一个元素
array.unshift() 方法
```js
const names = ['小智']
names.unshift('前端小智')
names // ["前端小智", "小智"]
```

#### 数组里面有两个元素，在两个元素中间再假如一个元素

#### 数组合并
```js
let a = [1, 2, 3];
let b = [4, 5, 6];
let c = [7, 8, 9];

//1.concat() 合并多个数组，不影响原数组(会造成内存浪费)，不能处理嵌套数组。
const r = a.concat(b); 
console.log(a); // [1, 2, 3]
console.log(b); // [4, 5, 6]
console.log(r); // [1, 2, 3, 4, 5, 6]

//如果 a 数组有10000个元素, b 数组也有有10000个元素, 那么数组r就有20000个元素, 这种方式占用了2倍的内存。a = b = null;就会被垃圾回收机制回收。

//2.基于for循环 - push():没有concat的内存浪费，看上去土而且不好维护, 只能合并两个数组，会改变原数组，不能处理嵌套数组。
// for(let i in b) {
//     a.push(b[i]);
// }
// console.log(a); // [1, 2, 3, 4, 5, 6]
// console.log(b); // [4, 5, 6]

//3.apply:简洁高效，能实现多个数组合并, 会改变原数组, 并且能够实现深度嵌套。
// a.push.apply(a, b);
// console.log(a); // [1, 2, 3, 4, 5, 6]
// console.log(b); // [4, 5, 6]

//更优美的push:多个数组合并, 会改变原数组, 效率比较高
a.push(...b, ...c)
console.log(a); // [1, 2, 3, 4, 5, 6, 7, 8, 9]
console.log(b); // [4, 5, 6]
console.log(c); // [7, 8, 9];
```
**为什么 Array.concat 这么慢？**
合并拥有大小为 10 的数组 10000 次，`.concat` 的速度为 0.40 ops/sec（操作每秒），而 `.push` 的速度是 378 ops/sec。也就是说 `push` 比 `concat` 快了整整 945 倍！这种差异可能不是线性的，但在这种小规模数据量上已经很明显了。

这与它们的运行机制有很大的关系：在合并数组的时候，**`.concat` 创建了一个新的数组**，而 **.push 只是修改了第一个数组**。这些额外的操作（将第一个数组的元素添加到返回的数组里）就是拖慢了 `.concat` 速度的关键。

#### 数组的遍历

#### 对一个对象做属性遍历要怎么操作

![image-20230318195713622](image/image-20230318195713622.png)

#### 递归应该怎么写

#### 原型链的理解

1. Person.prototype.constructor == Person // **准则1：原型对象（即Person.prototype）的constructor指向构造函数本身**
2. person01.__proto__ == Person.prototype // **准则2：实例（即person01）的__proto__和原型对象指向同一个地方**

JavaScript 常被描述为一种基于原型的语言 (`prototype-based language`)——每个实例对象（ `object` ）都有一个私有属性（称之为 `proto` ）指向它的构造函数的原型对象（`prototype` ）。该原型对象也有一个自己的原型对象( `proto` ) ，层层向上直到一个对象的原型对象为 `null`。根据定义，`null` 没有原型，并作为这个原型链中的最后一个环节。




#### 闭包以及闭包的应用场景

#### css问题，容器的子元素在水平方向和垂直方向同时居中
常见的垂直水平居中方法

1. position(父relative，子absolute)+margin负值的方法 (宽高固定)(left,top:50%左上角的点在中间)
2. position+margin:auto（固定宽高)（left,top.right,bottom:0)
3. display:table-cel + vertical-align:middle (固定穿度）
4. position+transform (不需要固定宽高)(场景最多，transform: translate(-50%，-50%);)
5. flex (不需要固定宽高)
```css
父级元素
display: flex;
justify-content: center;
align-items: center;
```

#### http状态码
##### 状态码分类
- 1xx - 服务器收到请求。
- 2xx - 请求成功，如 200。
- 3xx - 重定向，如 302。
- 4xx - 客户端错误，如 404。
- 5xx - 服务端错误，如 500。

##### 常见状态码
- 200 - 成功。
- 301 - 永久重定向（配合 location，浏览器自动处理）。
- 302 - 临时重定向（配合 location，浏览器自动处理）。
- 304 - 资源未被修改。
- 403 - 没权限。
- 404 - 资源未找到。
- 500 - 服务器错误。
- 504 - 网关超时。


#### promise

#### promise是宏任务还是微任务
微任务，讲事件循环

#### 平时爱好
动漫，关注比较新的科技事件

#### 最近比较关注的科技事件





### 同花顺
#### 自我介绍
#### 项目介绍
#### 项目难点
#### vue的生命周期

#### vue自带函数
#### vue 的set
#### 数组有哪些操作
#### vue nexttick
#### promise
#### 希望加入什么样的团队
#### 自己的优势
#### es6印象最深的是
#### foreach和map的区别

map

- 和forEach类似
- 相同：不改变原数组
- 区别：map会返回新数组；forEach无返回值（undifined）

### 棕喜文化
#### jq和vue的区别
1. jQuery首先要获取到dom对象，然后对dom对象进行进行值的修改等操作 
2. Vue是首先把值和js对象进行绑定，然后修改js对象的值，Vue框架就会自动把dom的值就行更新。 
3. 可以简单的理解为Vue帮我们做了dom操作，我们以后用Vue就需要修改对象的值和做好元素和对 象的绑定，Vue这个框架就会自动帮我们做好dom的相关操作 
4. 这种dom元素跟随JS对象值的变化而变化叫做单向数据绑定，如果JS对象的值也跟随着dom元素的 值的变化而变化就叫做双向数据绑定


### 阿里电话面+笔试
#### 拍平数组
```js
const arr = [1,2,[3,4]];
console.log(arr.flat());//[1,2,3,4]

function flat(arr){
	const hasDeep = arr.some((item) => item instanceof Array);
	if(!hasDeep){
		return arr;
	}

	//return Array.prototype.concat.apply([],arr);//打散 参数[] 1 2 [3,4]，但是只能处理嵌套一层的情况
	
	const res = Array.prototype.concat.apply([],arr);
	return flat(res);//递归
}

function flat(arr){
	while(arr.some((item) => item instanceof Array)){
		arr = Array.prototype.concat.apply([],arr);
	}
	
	return arr;
}

let arr = [[0, 1], [2, 3], [4,[5,6,7]]]
const flat2 = function(arr){
   return arr.reduce((pre,cur)=>pre.concat(Array.isArray(cur)?flat2(cur):cur),[])
}
console.log(newArr(arr)); //[0, 1, 2, 3, 4, 5, 6, 7]
```

#### tree中找到对应name
```js
var tree = {
	id: 1,
	name: "中国",
	children: [
		{
			id: 2,
			name: "浙江",
			children:[
				{
					id: 3,
					name: '宁波'
				},
				{
					id: 5,
					name: '杭州',
					children: [
						{
							id: 6,
							name: '余杭区'
						}
					]
				},
			]
		},
		{
			id: 4,
			name: "北京"
		}
	]
}

function getTreeIdByName(tree, name) {
    // 检查当前节点的名称是否匹配
    if (tree.name === name) {
      return tree.id;
    }
    
    // 递归查找子节点
    for (let child of tree.children || []) {
      let result = getTreeIdByName(child, name);
      if (result !== null) {
        return result;
      }
    }
    
    // 没有找到对应名称
    return null;
}

var result = getTreeIdByName(tree，'余杭区');
console.log(result); // 6
```
#### new操作符的作用

#### this对象

#### apply，bind传的是什么，改变完之后再访问原函数，this指向是什么

#### 原型链的理解

#### 原型链顶端是什么

#### 函数和对象是否都有proto和prototype属性，有什么区别

#### 事件循环

#### 是进行完所有微任务然后进行宏任务吗

#### 浏览器缓存

#### cookie是按tab还是什么域名之类的进行分块

#### f5和ctrl+f5的区别

#### 跨域问题一般怎么解决


#### 跨域是谁做限制的

#### 跨域有安全性问题吗，有哪些安全性问题

#### 了解什么前沿技术、

#### 封装一个vue组件会怎么做，考虑什么原则
##### 样式设计
1. 整体风格，结构上美观：颜色统一，风格统一（扁平化，圆角）等，文字编码规范。（可以将所有变量写为js变量或者sass,less等预处理框架。）
2. 同时对于组件设计来说，需要满足一些需求：（以 element 为例）
	- 一致性 Consistency
		- 与现实生活一致：与现实生活的流程、逻辑保持一致，尊重用户的习惯的语言概念
		- 在界面中一致：所有元素和结构保持一致，比如设计样式、图标和文本、元素的位置等。
	- 反馈 feedback
		- 控制反馈：清晰让用户感知自己在操作
		- 页面反馈：操作后，通过页面元素变化清晰展现当前状态
	- 效率 efficiency
		- 简化流程：设计简洁直观的操作流程
		- 清晰明了：语言表达清晰且表意明确，让用户快速理解做出决策
		- 帮助用户识别：界面简单直白，帮助用户识别而非回忆
	- 可控 Controllability
		- 用户决策：根据场景可给与用户操作建议和安全提示，但不能替用户进行决策
		- 结果可控：用户可以自由地进行操作，包括撤销、回退、终止当前操作



### 迪普测试

### 昱能科技一二面

### 尼禄软件

#### import和require的区别
1. 你可以认为 `import` 就是相当于 `const`声明语句。 你可以认为 `require` 就是相当于 值的绑定。
2. 所以你修改 `require`的基本类型的值 与 原始文件无关， 但引用类型会影响。
3. 所以你修改 `import` 的引用类型的值也会影响。 `ECMAScript 6` 模块是静态装配的，而传统的 `Node.js` 模块却是动态加载的。
4. `nodejs`模块被封装在一个函数中（亦即是作为一个函数的函数体），这也是为什么我们称呼`require`是动态的原因。
5. 而import 导入的名字则是按 `const` 的规则来处理的，`import()` 是支持动态加载的。

#### 响应式布局是什么
https://juejin.cn/post/7154261916733407246

#### 进程和线程的区别
进程就是加载到内存并执行的程序。

引入线程前，分时操作系统采用时间片轮转的方式运行进程：操作系统给每个进程分配一个时间段，称作时间片。

如果在时间片结束时进程还在运行，就暂停这个进程的运行，并且操作系统将CPU分配给另一个进程。（这个过程叫做上下文切换）
>当进程暂停时，它会保存当前进程的状态（进程标识，进程使⽤的资源等），在下⼀次切换回来时根据之前保存的状态（CPU寄存器和程序计数器的内容）进⾏恢复，接着继续执⾏。

如果在时间片结束前，进程阻塞或结束运行，则操作系统会让CPU立即进行切换，不用等待时间片用完。

时间片的大小通常为10~100ms，加上CPU运算速度极快。因此从宏观上来看，所有的程序在 “同时” 进行。但事实上，对于单核CPU来说，任意时刻都只有一个进程在占用CPU资源。

### 农行
#### 前后端交互


### 中交信科
#### vue父子组件通信方式

### 测试
#### 为什么选则测试的岗位？
1. 对质量有高度要求：测试岗位是一个专注于产品质量的岗位，测试人员需要通过各种手段和方法来发现产品的问题和缺陷，帮助开发团队及时修复，从而提高产品的质量和稳定性。在这个角度上来说，我对质量有高度的要求，并且喜欢挑战自己。
2. 对技术有一定兴趣：测试岗位需要掌握一些测试工具和技术，例如测试用例设计、测试环境搭建、自动化测试等。我对这些技术有一定的兴趣，也有过一些相关的经验，并且喜欢探究技术背后的原理和实现细节。
3. 喜欢与人沟通合作：测试人员需要与开发人员、产品经理、运维人员等不同职能团队进行沟通和协作，以保障产品的质量和稳定性。我喜欢与人沟通和协作，并且能够处理好各种人际关系。
4. 具备问题解决能力：测试人员需要通过测试和调试来找出产品的问题和缺陷，并提供解决方案和建议，我具备问题解决能力，并且喜欢通过分析和思考来解决问题。

同时测试的岗位有其他的优点，比如：
1. 测试工作可以帮助我更深入地了解软件开发过程和技术细节，提高对软件系统的理解和分析能力。
2. 测试工作可以帮助我锻炼逻辑思维、分析和问题解决能力，培养敏锐的观察力和细致的工作态度。
3. 测试工作可以帮助你获得更全面的职业发展机会，包括测试工程师、测试管理、质量保证、软件开发等多个领域。

以上就是我选择测试岗位的几点原因。

#### 如何对一个系统给进行测试
1. 功能测试：验证系统是否能对业务功能正确运行并进行验证。测试用例可以包括输入不同类型的业务流程中用户可能会输入的数据、验证结果的正确性和准确性等。
2. 异常测试：测试系统对于异常情况的处理能力。例如，当输入数据结果格式错误、缺失或损坏时，系统是否能够正确处理并给出相应的错误提示或处理方式。
3. 性能测试：测试系统在加载和验证大量输入时的性能表现。可以评估系统的响应时间、吞吐量以及资源利用情况，确保系统能够在预期负载下正常运行。
4. 兼容性测试：验证系统在不同环境和平台上的兼容性。测试系统在不同操作系统、浏览器或设备上加载和验证结果的能力，确保系统能够正常工作并提供一致的用户体验。
5. 安全性测试：测试系统的安全性措施，防止未经授权的访问或篡改应当返回的结果。可以测试系统对于数据加密、访问控制和防护措施的有效性。
6. 集成测试：如果系统与其他组件或服务进行集成，需要进行集成测试，确保系统与其他组件的协同工作正常。
7. 回归测试：随着系统的迭代和更新，进行回归测试以确保新功不会破坏系统原本的功能和稳定性。
8. 用户体验测试：通过模拟用户的操作路径和使用场景，评估系统的用户体验，包括界面友好性、操作流畅性以及反馈及时性等。

具体的测试策略和测试用例设计应根据系统的需求和具体情况进行细化。测试人员应该全面考虑不同方面的测试，以确保这个系统能够稳定、可靠地工作。

#### 测试的流程
测试的流程通常包括以下几个阶段：

1. 需求分析阶段：测试人员需要仔细分析需求文档，理解系统的功能、性能、安全和用户体验等方面的需求，并根据需求制定测试计划。
2. 测试计划阶段：测试人员需要根据需求文档和测试策略，制定详细的测试计划，包括测试目标、测试环境、测试策略、测试用例、测试人员和测试进度等。
3. 测试设计阶段：测试人员需要根据测试计划，设计测试用例，包括正常情况测试用例和异常情况测试用例。测试用例需要考虑覆盖系统的所有功能和场景，并保证测试用例的可重复性和可执行性。
4. 测试执行阶段：测试人员按照测试计划和测试用例进行测试执行，记录测试结果并对异常情况进行详细的描述和分析。
5. 缺陷管理阶段：测试人员需要将测试过程中发现的缺陷进行记录、分类和管理，并与开发人员沟通，确认缺陷是否需要修复。测试人员需要跟踪缺陷的修复情况，并进行验证测试。
6. 测试报告阶段：测试人员需要根据测试结果，编写测试报告，包括测试概要、测试过程、测试结果、缺陷统计和建议等内容，并向相关人员提交测试报告。
7. 测试结束阶段：测试人员需要对测试过程进行总结和反思，包括测试计划和测试执行过程的优缺点，提出改进建议，并归档测试文档和测试报告。

测试流程是一个不断循环迭代的过程，测试人员需要不断优化测试策略和测试用例，以保证测试的全面性和有效性。同时，测试人员还需要与其他团队成员进行沟通和协作，共同推动系统的稳定性和可靠性。

#### 那你们像bug、测试用例这些东西是怎么保管的呢？
1. 手工管理方式：手工管理方式通常采用文档和表格来记录测试用例和缺陷信息，例如使用Excel表格进行管理。手工管理方式的优点是简单易懂，适合小规模测试项目。但是手工管理方式容易出现重复和错误，也难以进行统计和分析。
2. 缺陷管理工具：缺陷管理工具可以帮助测试人员对缺陷信息进行跟踪和管理。常见的缺陷管理工具包括JIRA、Bugzilla、Mantis等。这些工具可以记录缺陷的详细信息，如缺陷描述、严重程度、状态等，同时也支持缺陷的分派、处理和统计等功能。
3. 测试管理工具：测试管理工具可以帮助测试人员对测试用例进行管理和跟踪。常见的测试管理工具包括TestRail、Zephyr等。这些工具可以记录测试用例的详细信息，如测试步骤、预期结果、实际结果等，同时也支持测试计划的制定、执行和统计等功能。
4. 自动化测试工具：自动化测试工具可以帮助测试人员自动执行测试用例，并自动生成测试报告。常见的自动化测试工具包括Selenium、Appium、Robot Framework等。这些工具可以提高测试效率和准确性，但需要一定的技术水平和投入成本。

#### TCP三次握手
1. 客户端向服务器发送一个带有SYN标志的连接请求报文段（SYN=1，ACK=0）。
2. 服务器收到请求报文后，回复一个带有SYN/ACK标志的确认报文段（SYN=1，ACK=1），表示确认客户端的请求，并告诉客户端服务器也准备好了。
3. 客户端收到确认报文后，再回复一个带有ACK标志的确认报文段（SYN=0，ACK=1），表示已经接收到服务器的确认，并告诉服务器可以开始通信了。
这样，客户端和服务器之间就完成了TCP三次握手过程，建立了可靠的连接，可以进行数据传输了。值得注意的是，如果任何一次握手失败或超时，TCP协议会重新发起握手过程，直到连接成功建立或达到最大重试次数。

#### 什么是软件质量
软件质量是指软件产品满足用户需求和期望的程度，包括软件功能、可靠性、易用性、效率、可维护性、可移植性和安全性等方面。具体来说，软件质量可以从以下几个方面进行定义和评估：

1. 功能性：软件是否满足用户需求和期望，功能是否正常，是否有误差或漏洞等。
2. 可靠性：软件是否稳定、可靠，是否容易出错或崩溃等。
3. 易用性：软件是否易于使用、操作，是否符合用户习惯，是否容易理解和学习等。
4. 效率：软件是否能够快速响应用户请求，是否能够高效地完成任务等。
5. 可维护性：软件是否易于维护和更新，是否容易修复漏洞或升级功能等。
6. 可移植性：软件是否能够在不同的操作系统、平台和硬件环境下运行，是否易于移植和部署等。
7. 安全性：软件是否具有保密性、完整性和可用性，是否能够防止未经授权的访问、数据泄漏等安全问题。

软件质量是软件开发过程中一个重要的指标，它不仅影响到软件的可信度和可靠性，也关系到用户的体验和满意度。为了提高软件质量，软件开发团队需要采用科学的软件开发方法和测试方法，严格把控软件开发质量和测试质量，不断优化和完善软件产品，以满足用户的需求和期望。

#### 简述什么是静态测试、动态测试、黑盒测试、白盒测试、α测试 β测试
1. 静态测试：在软件开发的早期阶段，通过对软件需求、设计、代码等文档的检查和审查，来发现和纠正潜在的缺陷和错误的测试方法。
2. 动态测试：通过运行软件系统，对其功能、性能、安全等方面进行验证和测试的测试方法。
3. 黑盒测试：基于软件系统的功能和需求规格文档，独立于程序内部实现的测试方法。黑盒测试可以发现软件系统的功能缺陷和一些常见的错误。（等价类划分，边界值分析，判定表，决策表，因果图）
4. 白盒测试：基于软件程序的内部实现，通过检查程序的代码、流程和数据结构等内部细节，来发现潜在的逻辑错误、计算错误等问题。（语句，条件。判定，逻辑覆盖）
5. α测试：在软件系统开发完成之前，由开发者或测试人员在开发环境下，对系统进行的测试，也称为开发者测试。
6. β测试：在软件系统发布之前，由真实用户在真实环境下对系统进行的测试，目的是检查系统的易用性、兼容性、稳定性等问题。

功能、性能、安全、验收、回归、兼容性和可靠性

#### 目前主要的测试用例设计方法是什么？
1. 等价类划分法：将输入域划分为多个等价类，每个等价类包含相同的输入条件，并从每个等价类中选择一组输入值作为测试用例。
2. 边界值分析法：在等价类划分的基础上，针对输入域的边界条件进行测试用例设计，包括最小值、最大值、临界值等。
3. 判定表测试法：通过建立判定表来描述被测系统的输入、输出和条件之间的关系，从而生成测试用例。
4. 因果图测试法：通过建立因果图来描述被测系统的输入、输出和条件之间的因果关系，从而生成测试用例。
5. 状态图测试法：通过建立状态图来描述被测系统的各种状态转换，从而生成测试用例。

#### 软件生存周期及其模型是什么？
软件生命周期指软件从开始开发到最终停止使用的整个过程，包括需求分析、设计、编码、测试、运行和维护等阶段。软件生命周期模型则是对软件生命周期的各个阶段进行组织、管理和控制的框架或方法论，常见的软件生命周期模型包括：
1. 瀑布模型（Waterfall Model）：将软件生命周期分为需求分析、设计、编码、测试和维护五个阶段，每个阶段顺序依次执行，前一阶段的输出作为下一阶段的输入。
2. 原型模型（Prototype Model）：通过快速构建原型来验证需求，然后逐步完善原型，直至最终交付产品。
3. 增量模型（Incremental Model）：将软件开发分为多个增量，每个增量都是一个完整的软件系统，通过逐步添加新功能和完善已有功能来完成整个软件系统的开发。
4. 螺旋模型（Spiral Model）：将软件生命周期分为多个迭代，每个迭代包括计划、风险评估、开发和评审四个阶段，通过迭代来逐步完善软件系统。
5. 敏捷模型（Agile Model）：强调快速迭代和持续交付，通过小规模、高频率的迭代来逐步完善软件系统。

#### 测试计划工作的目的是什么？测试计划文档的内容应该包括什么？其中哪些是最重要的？
测试计划的工作目的是为了规划和组织测试活动，确保测试工作能够按照计划有序地进行，并最终满足产品质量要求。

测试计划文档通常包括以下内容：

1. 引言：介绍测试计划的编写目的、范围、编写依据和参考资料等。
2. 测试目标：明确测试的总体目标和具体测试目标，包括测试的产品版本、测试的类型、测试的目标用户等。
3. 测试范围：详细说明测试的覆盖范围和限制条件，包括测试的功能、性能、安全、兼容性等方面的内容。
4. 测试方法：描述测试的方法和技术，包括测试用例设计方法、测试工具、测试环境等方面的内容。
5. 测试资源：列出测试所需要的人员、设备、软件等资源，并说明测试资源的安排和管理方式。
6. 测试进度：制定测试的时间安排和进度计划，包括测试任务的分配、测试活动的顺序和时间等方面的内容。
7. 风险评估：评估测试过程中可能出现的风险和问题，并制定相应的风险管理计划。
8. 交付标准：制定测试结果的评估标准和交付标准，明确测试结果的质量要求和交付方式。

在这些模块中，测试目标、测试范围和测试方法是最为重要的内容，它们对测试活动的规划和组织起到了关键作用。

#### 如果一个 bug 出现，但出现概率很小，修复代价却很大，应该怎么办？
这个问题要从几个方面来考虑。
1. 严重性：首先需要确定这个 bug 的严重性，如果这个 bug 导致严重的安全漏洞或数据丢失，那么修复这个 bug 的代价可能值得承担。如果这个 bug 只是导致一些小的界面显示问题，那么修复的代价可能就不那么值得了。
2. 影响范围：需要考虑这个 bug 影响的用户范围，如果只是少数用户受影响，那么修复的优先级可能就不那么高。但如果这个 bug 影响到了大量用户，那么修复的优先级就应该提高。
3. 处理方法：如果这个 bug 可以通过增加日志、监控、告警等方式来监控和控制，而不是必须要修复，那么可能可以暂时不修复或者推迟修复时间。
4. 业务影响：需要考虑修复这个 bug 是否会对业务产生重大影响，比如需要下线服务或者升级用户端，如果对业务影响较大，可能需要慎重考虑。

综合这几个因素，可以考虑
1. 如果这个 bug 的严重性较高、影响范围广泛且业务受影响较大，那么可能需要优先修复，即使修复代价较大。
2. 如果这个 bug 影响范围较小，且影响不严重，可以考虑暂时不修复或者推迟修复时间，等到条件更成熟时再修复。
3. 如果这个 bug 的影响可以通过监控、告警等方式控制，那么可以不立即修复，但需要增加相关的监控和告警机制。

#### 如果公司要求你每天必须找到多少个 bug，但是你找不到，应该怎么办？
可以通过几个方面来审视自己的工作：
1. 工作量是否合理：如果公司要求你每天必须找到过多的 bug，而实际情况下可能没有那么多 bug 可以找到，那么你可以与领导或者同事沟通并说明情况，看是否可以协商减少任务量。
2. 工作方法是否合理：如果你的工作方法不够有效，可能会浪费时间和精力，导致无法找到足够的 bug。你可以与同事交流学习，了解更有效的工作方法和技巧。
3. 工作质量是否符合要求：如果你的工作质量不够好，可能会导致你无法找到足够的 bug。你可以回顾自己的工作记录，寻找改进的空间，或者请同事和领导提供反馈和建议。


#### 国内云业务
部署方式：
1. 公有云
2. 私有云
3. 混合云

提供的服务类型：
1. 基础设施即服务（IaaS）：为企业提供计算资源——包括服务器、网络、存储和数据中心空间
优点：无须投资自己的硬件，对基础架构进行按需扩展以支持动态工作负载，可根据需要提供灵活、创新的服务
2. 平台即服务（PaaS）：为基于云的环境提供了支持构建和交付基于Web的（云）应用程序的整个生命周期所需的一切
优点：开发应用程序使其更快地进入市场，在几分钟内将新Web应用程序部署到云中，通过中间件即服务降低复杂性
3. 软件即服务（SaaS）：在云端的远程计算机上运行，这些计算机由其他人拥有和使用，并通过网络和Web浏览器连接到用户的计算机
优点：可以方便快捷地使用创新的商业应用程序，可从任何连接其中的计算机上访问应用程序和数据，如果计算机损坏，数据也不会丢失，因为数据储存在云中


应用：
1. 云存储技术
云存储是云计算技术的一个延伸和应用，它是一个远程平台，通过存储虚拟化、分布式文件系统、底层对象化等技术，利用应用软件将网络中的海量存储设备集合起来，协同工作，共同构成一个向外提供可扩展存储资源的系统。对于用户来说，云存储并不是一种设备，而是一种由海量服务器和存储设备提供的数据服务。
通过各种网络接口，用户可以访问云存储服务并使用其中的存储、备份、访问、归档、检索等功能，大大方便了用户对数据资源进行管理。同时，用户仅需按其使用的存储量付费，无须进行存储设备的检测和维护。
云存储环境的可用性强、速度快、可扩展性强。云存储可以解决本地存储管理缺失问题，降低数据丢失率，提供高效便捷的数据存储和管理服务。
2. 开发测试云
开发测试云可以解决开发中的一些问题，通过构建一个个异构的开发测试环境，利用云计算的强大算力进行应用的压力测试，适合于对开发和测试需求多的企业和机构。通过友好的网页界面，开发测试云可以解决开发测试过程中的各种难题。
3. 大规模数据处理云
大规模数据处理云通过在云计算平台上运行数据处理软件和服务，充分利用云计算的数据存储能力和处理能力，处理海量数据。它可以帮助企业通过数据分析迅速发现商机，从而针对市场做出迅捷、准确的决策。
4. 杀毒云
杀毒云是安置了强大的杀毒软件的云，通过云中存储的庞大病毒特征库并利用云强大的数据处理能力，分析一个数据是否含有病毒。如果在数据中发现疑似病毒，就将有嫌疑的数据上传至云进行检测并处理。杀毒云可以准确、迅速地发现病毒，捍卫用户计算机的安全。


#### 安全性
(1)用户认证机制：如数据证书、智能卡、双重认证、安全电子交易协议

(2)加密机制

(3)安全防护策略：如安全日志、入侵检测、隔离防护、漏洞扫描

(4)数据备份与恢复手段：存储设备、存储优化、存储保护、存储管理

(5)防病毒系统


#### 华为文化
华为崇尚“狼”文化，推崇“床垫文化”。任正非说，企业发展就是要发展一批狼。狼有三大特性：一是敏锐的嗅觉；二是不屈不挠、奋不顾身的进攻精神；三是群体奋斗的意识。
双重利益驱动：坚持为祖国昌盛、为民族振兴、为家庭幸福而努力奋斗的双重利益驱动原则。
同甘共苦，荣辱与共：团结协作、集体奋斗是华为企业文化之魂。

#### 反问
1. 工作内容
2. 有没有入职培训，是怎么样的
3. 晋升流程
4. 表现如何



