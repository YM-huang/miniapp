### 准备
#### 自我介绍
面试官你好，我叫黄益妙，来自浙江工业大学软件工程专业的23届应届生。

作为一名软件工程的学生，我熟悉并掌握了多种前端技术，包括HTML、CSS、JavaScript等。我也具备一些比较流行的的前端框架和库的开发经验，例如bootstrap、jquery和Vue.js等。同时，我也理解前后端交互的机制并曾经和同学一起开发过一个大型车位管理系统的项目。在校期间我多次获得了学习奖学金和社会实践奖学金，积极参加竞赛，在电子商务大赛，服务外包大赛，网络安全大赛中都获得了省级以上的奖项。

我热爱学习和不断提升自己的技能，因此我经常关注前端技术的最新动态，在掘金、v2ex、github等社区阅读相关的博客和书籍。我也喜欢和其他开发者进行交流，分享我的经验和知识，偶尔在开源社区为一些开源项目提交pr，并且愿意在工作中协同团队中的其他成员，以实现最佳的开发效果。

如果给我机会成为杭州银行信息技术部的一员，我将竭尽全力为公司贡献我的技能和才华，并与团队协同工作，创造出优质的应用程序。谢谢！

#### 项目介绍
这个项目是一个智能开发商车位销售平台，我担任的是项目的一部分开发工作，负责用户模块的整体前后端代码开发，以及最终的软件测试。该项目主要使用了Spring框架实现前后端分离，Ajax实现数据异步传输，Json实现前后端数据交互，使用MySQL作为数据库，SpringMVC和MyBatis作为后端开发框架。

在项目开发过程中，我负责了整体逻辑的构建，包括用例、类、方法流程等的设计。在数据库的搭建方面，我负责了数据库的设计和优化SQL代码，以确保数据存储和访问的效率和准确性。

在用户模块的开发方面，我负责了整个模块的前后端代码开发，包括前端页面的设计和开发，后端业务逻辑的实现和数据传输的实现。同时，我还负责了最终的软件测试，包括单元测试和集成测试，以确保整个系统的功能和性能符合要求。

同时，我们组员在协同开发过程之中使用git来进行项目协同和版本控制，大大挺高了开发效率和减少开发成本。

总体来说，这个项目的目标是为开发商提供一个高效、智能的车位销售平台，使其能够更好地管理和销售车位，并为用户提供更好的购买体验。我在这个项目中的工作，是为实现这个目标做出了贡献。

##### 难点

1. 性能问题
   在我参与的企业网站开发项目中，我们使用了一些复杂的UI组件和动画效果，导致网站加载速度变慢。为了解决这个问题，我们使用了Webpack进行代码分割，只加载当前页面所需要的代码，减少了网站的加载时间。同时，我们使用了CDN来加速网站静态资源的加载。此外，我们还对图片进行了优化，使用了懒加载和预加载等技术来提高网站性能。

 |  	 | 懒加载	| 预加载|
 |  ---- | ----  | ---- |
 |  定义	| 延迟加载、按需加载	|提前加载、不需要也提前加载|
 |  目的	|更好更快地加载页面首屏内容，网页性能优化	|让用户无需等待，获得直接预览的良好体验|
 | 缺点	|需要监听图片是否显示，耗费浏览器性能	|占用较多的后台资源，可能一次性加载较多的图片|
 |  应用场景|	电商搜索产品时图片展示	|观看漫画时，每次切换的下一张图片提前加载|

2. 跨域问题
   在我参与的电子商务平台开发项目中，我们前后端分离，前端使用Vue.js作为框架，后端使用Node.js和MongoDB。在前端向后端发送请求时，由于跨域问题，导致请求被浏览器拦截。为了解决这个问题，我们使用了Vue.js提供的代理模式，在开发模式下将前端请求代理到后端。在生产环境下，我们使用了Nginx反向代理来解决跨域问题。

3. 数据库设计问题
   在我参与的微信小程序开发项目中，我们使用了小程序云开发提供的数据库服务。在设计数据库时，我们遇到了一些问题，例如数据结构不合理、查询性能较差等。为了解决这个问题，我们对数据进行了重新设计，使用了适当的索引来提高查询性能。我们还对数据库进行了数据分片，将数据存储在多个集合中，以减少单个集合中的数据量。

以上是我在项目中遇到的一些难点以及解决方法。在实际项目中，我们会遇到各种各样的问题，关键在于能够快速找到问题所在，并采取有效的解决方案。这需要我们具备良好的沟通能力、团队协作能力以及快速学习和解决问题的能力。

1. 前后端数据交互问题：由于是前后端分离的开发模式，需要使用Ajax和Json实现数据交互。在实现过程中，需要考虑如何处理前端发送的请求并返回正确的响应，以及如何在前端页面正确地解析后端返回的数据。
2. 大规模数据存储问题：由于项目需要存储大量的数据，如车位信息、用户信息等，需要考虑如何设计和优化数据库，以确保数据的存储和访问的效率和准确性。
3. 多人协作问题：由于项目需要多人协作开发，需要考虑如何合理地分配任务、协同开发以及如何处理代码冲突等问题，以确保项目能够高效地进行。
针对这些问题，我通过学习相关知识和与团队成员沟通协作，最终解决了这些问题。比如，在前后端数据交互方面，我通过学习相关的技术和与后端开发人员的沟通，成功地实现了数据的正确传输和解析；在数据库设计和优化方面，我使用了相关的工具和技术，如SQL语句的优化等，来提高数据库的性能和准确性；在多人协作方面，我使用了Git等版本控制工具来协同开发和解决代码冲突等问题。


#### SQL优化
1、对查询进行优化，应尽量避免全表扫描；
2、应尽量避免在where子句中对字段进行null值判断；
3、应尽量避免在where子句中使用!=或<>操作符；
4、“in”和“not in”也要慎用，否则会导致全表扫描。
5、对于一些比较复杂，重用度比较高的逻辑会建立触发器来简化代码

#### 加班
进行前端工作是一个非常细致的过程，在我以往的项目经验来看，每一个项目都有一些重要的节点，这需要整个团队都付出额外的努力和时间，对此我表示十分地理解，因为这是我们需要做的核心工作。在我看来，如果加班是必要的，那我愿意投入额外的时间，并推动工作的发展，如果加班是因为其他的情况导致一些工作效率低下造成的，那我会做的是找出效率低下的原因，并找到自己和团队能够改善的方法

作为一个前端工程师，我认为加班是必要的，但是不能成为常态。在项目紧急的情况下，必须要进行加班来满足项目的进度和质量要求，但同时需要合理安排工作和生活，保持身体和心理的健康。如果加班成为常态，可能说明问题出在项目的规划和管理上，需要重新评估项目的进度和资源分配。

在加班时，我认为需要有效地利用时间，合理安排任务，避免无效的加班。同时需要与团队成员充分沟通，合理分配任务，减少因个人原因引起的加班。最后，在加班结束后，需要适当地休息和放松，保持健康的生活方式。

#### bunjs性能
- 不同于 Node.js 和 Deno，Bun 使用了 JavaScriptCore 引擎，其启动和执行速度比 V8 引擎要快一些；
- 使用了新兴的系统编程语言 Zig，主要通过手动内存管理对内存进行更细粒度的控制、无隐藏的控制流来提升程序的性能；
- 在前两点的前提下，重新实现了诸如 JSX/TypeScript 转编器、SQLite 客户端、HTTP 客户端、WebSocket 客户端等类库。

#### core-js简介
core-js是**完全模块化的javascript标准库**。 包含ECMA-262至今为止大部分特性的polyfill，如promises、symbols、collections、iterators、typed arrays、etc，以及一些跨平台的WHATWG / W3C特性的polyfill，如WHATWG URL。 它可以直接全部注入到全局环境里面，帮助开发者模拟一个包含众多新特性的运行环境，这样开发者仅需简单引入core-js，仍然使用最新特性的ES写法编码即可；也可以不直接注入到全局对象里面，这样对全局对象不会造成污染，但是需要开发者单独引入core-js的相关module，并可能还需要通过手工调用module完成编码，没法直接使用最新ES的写法。它是一个完全模块化的库，所有的polyfill实现，都有一个单独的module文件，既可以一劳永逸地把所有polyfill全部引入，也可以根据需要，在自己项目的每个文件，单独引入需要的core-js的modules文件。

### 恒生一面

#### 自我介绍

#### 项目经历，以及怎么实现
   1. 项目的背景是什么
   2. 当前项目的目的是什么
   3. 在开发过程中，我的角色是什么
   4. 在开发过程中遇到什么难题
   5. 遇到这些问题都是怎么解决的
   6. 项目完成后取得了哪些成果

#### 项目中的难点以及怎么解决
   * 业务/技术
   * 翻页需求（SQL和前端适配）
通过传入参数，限制页数和每页的数量
```xml
   <select id="selectOrder" parameterType="java.util.Map" resultType="com.bean.Order">
        select `order`.* from `order`,`parking_space`,`residential_quarters`
    <where>
        `order`.parking_space_id=`parking_space`.id and
        `parking_space`.residential_quarters_id = `residential_quarters`.id and
        `residential_quarters`.developer_id=#{did}
        <if test="search != null and search !=''">
            and `order`.`state` like concat('%', #{search}, '%')
            or `order`.`order_time` like concat('%', #{search}, '%')
            or `order`.`order_id` = #{search}
        </if>
    </where>
    LIMIT ${(pageNum-1)*pageSize},${pageSize*pageNum};
    </select>
```
   * 跟被人协作时 git问题等等
   * youtube上那个展开

#### 使用什么框架，vue的生命周期以及其对应构造函数

#### 跟他人协调，以及遇到的困难。

#### 闭包

闭包是指一个函数可以访问并操作在其定义外部的变量，即使这个函数在外部变量的作用域之外被调用，也能访问到这些变量。这是因为在JavaScript中，每个函数都会创建一个自己的作用域，包括函数中定义的局部变量和函数的参数，以及在函数定义时在外部作用域中定义的变量。

当一个函数内部引用了在外部作用域中定义的变量时，JavaScript会自动创建一个闭包来保存这个变量的引用。闭包是由函数和其对应的作用域组成的，它可以在函数外部访问并操作在函数定义时存在的作用域中的变量。这种机制可以让JavaScript中的函数具有更大的灵活性和可重用性。

例如，以下代码演示了如何创建和使用闭包：

function createCounter() {
  var count = 0;
  function counter() {
    count++;
    console.log(count);
  }
  return counter;
}

var myCounter = createCounter();
myCounter(); // 输出 1
myCounter(); // 输出 2

在这个例子中，createCounter 函数返回一个内部函数 counter。counter 内部引用了在外部作用域中定义的 count 变量。当 myCounter 被调用时，count 变量的值被增加，并输出到控制台。由于 myCounter 是 createCounter 返回的 counter 函数，它可以访问并操作 createCounter 定义时存在的作用域中的变量，也就是闭包的概念。

#### this关键字

在JavaScript中，this 关键字指向当前函数的执行上下文，它的值在每个函数调用时动态计算，具体取决于函数被调用时的调用方式以及执行上下文的类型。 this 的值在运行时确定，而不是在函数定义时确定。

this 的值在 JavaScript 中有四种调用方式：

1. 默认绑定：当一个函数独立调用时，this 指向全局对象，即 window 对象。

2. 隐式绑定：当一个函数作为对象的方法调用时，this 指向调用该方法的对象。

3. 显式绑定：通过 call()、apply() 或者 bind() 方法将一个函数绑定到指定对象上，并且 this 指向指定对象。

4. new 绑定：通过 new 关键字创建一个新的实例对象时，this 指向这个新对象。


另外，作用域是指一个变量的可访问范围。在 JavaScript 中，有函数作用域和块级作用域两种作用域。函数作用域指的是在函数内部定义的变量只在该函数内部可见，而在函数外部无法访问。块级作用域是指在代码块内定义的变量只在该代码块内可见。

当一个函数被调用时，它会创建一个新的执行上下文，这个执行上下文包含了当前函数的作用域以及 this 的值。函数内部可以访问当前作用域和上层作用域中定义的变量，但是不能访问函数外部的作用域中定义的变量。在 JavaScript 中，作用域链用来描述一个函数在执行时如何访问变量的，它是由当前函数的作用域以及上层作用域构成的。

总结一下，this 关键字用于确定当前函数的执行上下文，作用域用于确定一个变量的可访问范围。在 JavaScript 中，要理解好 this 和作用域，可以帮助我们写出更加清晰和可维护的代码。

#### 有什么要问面试官的
   * 觉得我怎么样
   * 总共几轮面试
   * 团队用的技术栈
   * 团队的人员架构
   * 团队协作工具/开发工具/流程工具是什么，如何沉淀文档
   * 未来团队计划补充到多少人

### 杭州银行（总行信息技术部-前端）
#### 自我介绍
#### 关注前端的哪些事件
#### 介绍一下core-js
>core-js是完全模块化的javascript标准库。 包含ECMA-262至今为止大部分特性的polyfill，如promises、symbols、collections、iterators、typed arrays、etc，以及一些跨平台的WHATWG / W3C特性的polyfill，如WHATWG URL。 **它可以直接全部注入到全局环境里面，帮助开发者模拟一个包含众多新特性的运行环境，这样开发者仅需简单引入core-js，仍然使用最新特性的ES写法编码即可；**也可以不直接注入到全局对象里面，这样对全局对象不会造成污染，但是需要开发者单独引入core-js的相关module，并可能还需要通过手工调用module完成编码，没法直接使用最新ES的写法。它是一个完全模块化的库，所有的polyfill实现，都有一个单独的module文件，既可以一劳永逸地把所有polyfill全部引入，也可以根据需要，在自己项目的每个文件，单独引入需要的core-js的modules文件。

#### 介绍项目
#### vue生命周期
* beforeCreate: 实例刚被创建，数据观测和事件机制未初始化，此时无法访问到 data、methods、computed 等属性和方法。
* created: 实例已经创建完成，此时已经完成了数据观测和事件机制的初始化，可以访问到 data、methods、computed 等属性和方法。
* beforeMount: 模板编译完成，但未挂载到 DOM 上。
* mounted: 模板编译完成，已经挂载到 DOM 上，此时可以访问到渲染后的 DOM。
* beforeUpdate: 数据更新前，DOM 尚未重新渲染。
* updated: 数据更新后，DOM 已经重新渲染。
* beforeDestroy: 实例销毁前，此时实例仍然可用。
* destroyed: 实例已经销毁，此时实例中的所有东西都已被清理掉。
![image-20230301150128879](image/image-20230301150128879.png)

#### js类型
>值类型(基本类型)：字符串（String）、数字(Number)、布尔(Boolean)、空（Null）、未定义（Undefined）、Symbol。
>引用数据类型（对象类型）：对象(Object)、数组(Array)、函数(Function)，还有两个特殊的对象：正则（RegExp）和日期（Date）。
>注：Symbol 是 ES6 引入了一种新的原始数据类型，表示独一无二的值。

#### 哈希表

数组的特点是：寻址容易，插入和删除困难；

而链表的特点是：寻址困难，插入和删除容易。

应用：

1、Hash主要用于信息安全领域中加密算法，它把一些不同长度的信息转化成杂乱的128位的编码,这些编码值叫做Hash值. 也可以说，Hash就是找到一种数据内容和数据存放地址之间的映射关系。

2、查找：哈希表，又称为散列，是一种更加快捷的查找技术。我们之前的查找，都是这样一种思路：集合中拿出来一个元素，看看是否与我们要找的相等，如果不等，缩小范围，继续查找。而哈希表是完全另外一种思路：当我知道key值以后，我就可以直接计算出这个元素在集合中的位置，根本不需要一次又一次的查找！

举一个例子，假如我的数组A中，第i个元素里面装的key就是i，那么数字3肯定是在第3个位置，数字10肯定是在第10个位置。哈希表就是利用利用这种基本的思想，建立一个从key到位置的函数，然后进行直接计算查找。

3、Hash表在海量数据处理中有着广泛应用。

#### 数据结构有哪些

https://hit-alibaba.github.io/interview/basic/algo/Hash-Table.html

* 数组（Array）
* 队列（Queue）
* 链表（Linked List）
* 栈（Stack）
* 树（Tree）
* 散列表（Hash）
* 堆（Heap）
* 图（Graph）

##### 数组(Array)
数组是最简单、使用最频繁的一种数据结构。它一种线性表数据结构，用一组连续的内存空间来存储一组相同类型的数据。

![image-20230302115519132](image/image-20230302115519132.png)

##### 队列(Quene)

队列也是一种非常基础的数据结构，其特点是先入先出，也就是我们常听到的FIFO（First in First Out），即操作数据是从两端进行的。

![image-20230302115628865](image/image-20230302115628865.png)

##### 链表(Linked List)

链表是一种物理存储单元上非连续，非顺序的存储结构。链表有一系列节点组成，所谓节点就是指链表中的每一个元素，每个节点包含两个数据，一个是存储元素的数据域（值），另一个是存储下一个节点地址的指针域。

![image-20230302115702717](image/image-20230302115702717.png)

通俗点说，链表数据一般都是分散存储于内存中 的，无须存储在连续空间内。这样大家可能还不能直观的感受链表的非连续，我再画一张图：

![image-20230302120103857](image/image-20230302120103857.png)

假设上图中100-108是一块内存中连续地址的内存分布，假设101、103、106、107这几个内存地址都已经存储数据了，那剩下的100、102、104、105、108是不是就浪费呢，答案是否定的，我们可以使用链表的方式存储数据。

##### 栈(Stack)

栈也是一种数据呈线性排列的数据结构，和上面的队列相反，栈的特点先进后出、后进先出，就是常说的LIFO（Last in First Out）。

![image-20230302120356051](image/image-20230302120356051.png)

##### 树(Tree)

树形结构是一种层级式的数据结构，由顶点（节点）和连接它们的边组成。
数的结构特点是：

- 每个节点有零个或多个子节点；
- 没有父节点的节点称为根节点；
- 每一个非根节点有且只有一个父节点；
- 除了根节点外，每个子节点可以分为多个不相交的子树。

我们平时用到最多的就是二叉树，我也以二叉树来为例，先看一下树结构：

![image-20230302120523184](image/image-20230302120523184.png)

二叉树有几下特点：

- 每个结点最多有两颗子树，结点的度最大为2。
- 左子树和右子树是有顺序的，次序不能颠倒。
- 即使某结点只有一个子树，也要区分左右子树。
- 个结点的值均大于其左子树上任意一个结点的值。比如 点的值。结点100大于其左子树上的30，18和16。
- 每个结点的值均小于其右子树上任意 一个结点的值。比如结点 100 小于其右子树上的 120、130 和 135。

##### 散列表(Hash)

散列表又叫哈希表，存储的是由键(key)和值(value)组 成的数据，根据键直接访问存储在内存存储位置的数据结构。

![image-20230302120644443](image/image-20230302120644443.png)

从图中可以看出，左边很明显是个数组，数组的每个成员包括一个指针，指向一个链表的头，当然这个链表可能为空，也可能元素很多。我们根据元素的一些特征把元素分配到不同的链表中去，也是根据这些特征，找到正确的链表，再从链表中找出这个元素。**哈希表查找数据的公式为：记录的存储位置=f(key)**这里的对应关系 f 成为散列函数，又称为哈希 (hash函数)，而散列表就是把Key通过一个固定的算法函数既所谓的哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里，这种存储空间可以充分利用数组的查找优势来查找元素，所以查找的速度很快。我们将在后面详细讲解哈希表数据结构。

##### 堆(Heap)

堆比较特殊，是一种图的树形结构。被用于实现“优先队列”(priority queues)，优先队列是一种数据结构，可以自由添加数据，但取出数据时要从最小值开始按顺 序取出。在堆的树形结构中，各个顶点被称为“结点”(node)，数据就存储在这些结点中。
只要满足下面两个特点的树形结构就是堆：

- 堆是一个完全二叉树（所谓完全二叉树就是除了最后一层其他层的节点个数都是满的）。
- 堆中每一个节点的值都必须大于等于或者小于其子树中每一个节点的值。

下面我们看一下堆的结构：

![image-20230302132123031](image/image-20230302132123031.png)

上面其实叫大顶堆，如果每一个节点小于子树中每个节点的值，那就叫小顶堆。

##### 图(Graph)

图是相对复杂的一种数据结构，由顶点和连接每对顶点的边所构成的图形就是图。
我们先来看图：

![image-20230302132205176](image/image-20230302132205176.png)

上图中的圆圈叫作“顶点”(Vertex，也叫“结点”)，连接顶点的线叫作“边”（Edge）。也就是说，由顶点和连接每对顶点的边所构成的图形就是图。 图按照顶点指向的方向可分为无向图和有向图，像我上面的就叫无向图。 图在存储数据上有着比较复杂和高效的算法，分别有邻接矩阵 、邻接表、十字链表、邻接多重表、边集数组等存储结构。常见的图遍历算法就是广度优先算法和深度优先算法。


#### 原子性
>数据库管理系统中事务(transaction)的四个特性（分析时根据首字母缩写依次解释）：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）
>所谓事务，它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。（执行单个逻辑功能的一组指令或操作称为事务）
>1. 原子
>>原子性是指事务是一个不可再分割的工作单元，事务中的操作要么都发生，要么都不发生。
>>可采用“A向B转账”这个例子来说明解释
>>在DBMS中，默认情况下一条SQL就是一个单独事务，事务是自动提交的。只有显式的使用start transaction开启一个事务，才能将一个代码块放在事务中执行。
>2. 一致性
>>一致性是指在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。这是说数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。
>>如A给B转账，不论转账的事务操作是否成功，其两者的存款总额不变（这是业务逻辑的一致性，至于数据库关系约束的完整性就更好理解了）。
>>保障机制（也从两方面着手）：数据库层面会在一个事务执行之前和之后，数据会符合你设置的约束（唯一约束，外键约束,check约束等)和触发器设置；此外，数据库的内部数据结构（如 B 树索引或双向链表）都必须是正确的。业务的一致性一般由开发人员进行保证，亦可转移至数据库层面。
>3. 隔离性
>>多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。
>>在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看到中间状态的数据。
>>事务最复杂问题都是由事务隔离性引起的。完全的隔离性是不现实的，完全的隔离性要求数据库同一时间只执行一条事务，这样会严重影响性能。
>>关于隔离性中的事务隔离等级（事务之间影响），参见相应博文
>4. 持久性
>>这是最好理解的一个特性：持久性，意味着在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。（完成的事务是系统永久的部分，对系统的影响是永久性的，该修改即使出现致命的系统故障也将一直保持）
>>write ahead logging：SQL Server中使用了WAL（Write-Ahead Logging）技术来保证事务日志的ACID特性，在数据写入到数据库之前，先写入到日志，再将日志记录变更到存储器中。

#### 数据库建立索引要在哪些建立
索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。
>1. 在经常搜索的列上创建索引，能够加快搜索的速度；
>2. 在作为主键的列上创建索引，需要强制该列的唯一性和组织表中数据的排列结构；
>3. 在经常被用在连接的列上(主要是外键)建立索引，可以加快连接速度。
>4. 在经常使用WHERE子句的列上建立索引，加快条件的判断速度。当增加索引时，会提高检索性能，加快条件的判断速度，但是会降低修改性能。
>
>参考：https://cloud.tencent.com/developer/article/1769263

#### 为什么要选择杭州银行
我非常感谢您提出这个问题。我选择杭州银行，主要是基于以下几点原因：

首先，杭州银行是一家具有良好声誉和潜力的金融机构，其稳定的发展和创新的精神吸引了我。随着金融科技的快速发展，杭州银行也在不断地推出新的数字化服务，这些服务为客户提供了更高效、便捷、安全的银行服务，同时也带动了金融科技的发展。作为一名前端开发人员，我希望能够参与这个领域的创新，并为银行的数字化转型贡献自己的力量。

其次，我对杭州这个城市也有着浓厚的兴趣。作为一个有着丰富历史和文化底蕴的城市，杭州有着许多美丽的景点和富有活力的社区。在这个城市工作和生活，我相信可以感受到它的多元化和包容性，并且拥有更多的机会与人们进行交流和互动。

最后，我相信杭州银行可以为我提供一个良好的职业发展平台。作为一家金融机构，杭州银行有着完善的组织架构和职业发展路径，它也注重培养员工的技能和知识，为员工提供了广泛的培训和晋升机会。我希望能够成为杭州银行信息技术部的一员，与公司一起成长和发展，创造更多的价值。
#### v2 v3 的差别
>(https://worktile.com/kb/ask/19553.html)
>vue2和vue3的区别有以下8点：1、双向数据绑定原理不同；2、是否支持碎片；3、API类型不同；4、定义数据变量和方法不同；5、生命周期钩子函数不同；6、父子传参不同；7、指令与插槽不同；8、main.js文件不同。
>
>1. 双向数据绑定原理不同
>>vue2：vue2的双向数据绑定是利用ES5的一个APIObject.definePropert() 对数据进行劫持，结合发布订阅模式的方式来实现的。
>>vue3：vue3中使用了ES6的Proxy API对数据代理。相比vue2.x，使用proxy的优势如下：
>>
>>* defineProperty只能监听某个属性，不能对全对象监听
>>* 可以省去for in，闭包等内容来提升效率(直接绑定整个对象即可)
>>* 可以监听数组，不用再去单独的对数组做特异性操作vue3.x可以检测到数组内部数据的变化。
>
>2. 是否支持碎片
>>vue2：vue2不支持碎片。
>>vue3：vue3支持碎片（Fragments），就是说可以拥有多个根节点。
>
>3. API类型不同
>>vue2：vue2使用选项类型api，选项型api在代码里分割了不同的属性：data,computed,methods等。
>>vue3：vue3使用合成型api，新的合成型api能让我们使用方法来分割，相比于旧的api使用属性来分组，这样代码会更加简便和整洁。
>
>4. 定义数据变量和方法不同
>>vue2：vue2是把数据放入data中，在vue2中定义数据变量是data(){}，创建的方法要在methods:{}中。
>>vue3：，vue3就需要使用一个新的setup()方法，此方法在组件初始化构造的时候触发。使用以下三个步骤来建立反应性数据： 
>>* 从vue引入reactive；
>>* 使用reactive() 方法来声明数据为响应性数据；
>>* 使用setup()方法来返回我们的响应性数据，从而template可以获取这些响应性数据。
>
>5. 生命周期钩子函数不同
>>vue2：vue2中的生命周期：
>>* beforeCreate 组件创建之前
>>* created 组件创建之后
>>* beforeMount 组价挂载到页面之前执行
>>* mounted 组件挂载到页面之后执行
>>* beforeUpdate 组件更新之前
>>* updated 组件更新之后
>
>>vue3：vue3中的生命周期：
>>* setup 开始创建组件
>>* onBeforeMount 组价挂载到页面之前执行
>>* onMounted 组件挂载到页面之后执行
>>* onBeforeUpdate 组件更新之前
>>* onUpdated 组件更新之后
>
>>而且vue3.x 生命周期在调用前需要先进行引入。除了这些钩子函数外，vue3.x还增加了onRenderTracked 和onRenderTriggered函数。
>
>6. 父子传参不同
>>vue2：父传子，用props,子传父用事件 Emitting Events。在vue2中，会调用this$emit然后传入事件名和对象。
>>vue3：父传子，用props,子传父用事件 Emitting Events。在vue3中的setup()中的第二个参数content对象中就有emit，那么我们只要在setup()接收第二个参数中使用分解对象法取出emit就可以在setup方法中随意使用了。
>
>7. 指令与插槽不同
>>vue2：vue2中使用slot可以直接使用slot；v-for与v-if在vue2中优先级高的是v-for指令，而且不建议一起使用。
>>vue3：vue3中必须使用v-slot的形式；vue3中v-for与v-if,只会把当前v-if当做v-for中的一个判断语句，不会相互冲突；vue3中移除keyCode作为v-on的修饰符，当然也不支持config.keyCodes；vue3中移除v-on.native修饰符；vue3中移除过滤器filter。
>
>8. main.js文件不同
>>vue2：vue2中我们可以使用pototype(原型)的形式去进行操作，引入的是构造函数。
>>vue3：vue3中需要使 用结构的形式进行操作，引入的是工厂函数；vue3中app组件中可以没有根标签。





### 华电电话面
#### const和let的区别
https://www.freecodecamp.org/chinese/news/javascript-var-let-and-const/
* var声明是全局作用域或函数作用域，而let和const是块作用域。
* var变量可以在其范围内更新和重新声明； let变量可以被更新但不能重新声明； const变量既不能更新也不能重新声明。
* 它们都被提升到其作用域的顶端。但是，虽然使用变量undefined初始化了var变量，但未初始化let和const变量。
* 尽管可以在不初始化的情况下声明var和let，但是在声明期间必须初始化const。

#### GET 和 POST 的区别。
- 从缓存的角度，GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。
- 从编码的角度，GET 只能进行 URL 编码，只能接收 ASCII 字符，而 POST 没有限制。
- 从参数的角度，GET 一般放在 URL 中，因此不安全，POST 放在请求体中，更适合传输敏感信息。
- 从幂等性的角度，GET 是幂等的，而 POST 不是。(幂等表示执行相同的操作，结果也是相同的)
- 从 TCP 的角度，GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分。(火狐浏览器除外，它的 POST 请求只发一个 TCP 包)

#### cookie和session的区别
https://www.51cto.com/article/679219.html

- 作用范围不同，Cookie 保存在客户端(浏览器)，Session 保存在服务器端。
- 存取方式的不同，Cookie只能保存 ASCII，Session可以存任意数据类型，比如UserId等。
- 有效期不同，Cookie可设置为长时间保持，比如默认登录功能功能，Session一般有效时间较短，客户端关闭或者Session超时都会失效。
- 隐私策略不同，Cookie存储在客户端，信息容易被窃取;Session存储在服务端，相对安全一些。
- 存储大小不同， 单个Cookie 保存的数据不能超过 4K，Session可存储数据远高于Cookie。


#### css id和name，什么时候用id，什么时候用name
https://www.jianshu.com/p/246ad0659e2a
#### 数据库：编号 时间 钱，编写一条sql找最多。